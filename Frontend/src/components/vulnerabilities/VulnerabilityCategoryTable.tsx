import React, { useState, useEffect, useMemo } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { RefreshCw, ArrowLeft, Shield, Key, Hash, Lock, Cpu } from "lucide-react";

// Types for API data
interface ApiCryptoAlgorithm {
  Section: string;
  Algorithm_Name: string;
  Category: string;
  Variant: string;
  Purpose: string;
  Usage_Context: string;
  Status_Today: string;
  PQC_Status: string;
  Priority: string;
  Classical_Recommended: string;
  Quantum_Recommended: string;
  NIST_Reference: string;
  Notes: string;
}
// Types for table data
interface CryptoAlgorithm {
  id: string;
  algorithm_name: string;
  variant: string;
  purpose: string;
  usage_context: string[];
  status_today: string;
  pqc_status: string;
  priority: string;
  classical_recommended: string;
  quantum_recommended: string;
  nist_reference: string[];
  notes: string;
  section: string; // Add section for better categorization
};

// API fetching and data processing
const fetchDataFromAPI = async (): Promise<ApiCryptoAlgorithm[]> => {
  try {
    const response = await fetch("https://backend-1-v77y.onrender.com/api/apps3");
    if (!response.ok) {
      throw new Error(`API Error: ${response.status} ${response.statusText}`);
    }
    const result = await response.json();
    console.log('✅ API data fetched successfully');
    return result.data || [];
  } catch (error) {
    console.error('❌ Failed to fetch data from API:', error);
    return [];
  }
};

const transformApiData = (apiData: ApiCryptoAlgorithm[]): CryptoAlgorithm[] => {
  return apiData.map((item, index) => ({
    id: `${item.Algorithm_Name}-${index}`,
    algorithm_name: item.Algorithm_Name,
    variant: item.Variant,
    purpose: item.Purpose,
    usage_context: item.Usage_Context ? item.Usage_Context.split(',').map(s => s.trim()) : [],
    status_today: item.Status_Today,
    pqc_status: item.PQC_Status,
    priority: item.Priority,
    classical_recommended: item.Classical_Recommended,
    quantum_recommended: item.Quantum_Recommended,
    nist_reference: item.NIST_Reference ? item.NIST_Reference.split(',').map(s => s.trim()) : [],
    notes: item.Notes,
    section: item.Section,
  }));
};

const categorizeApiData = (transformedData: CryptoAlgorithm[]) => {
  const categories: { [key: string]: CryptoAlgorithm[] } = {
    symmetric: [],
    asymmetric: [],
    hash: [],
    mac_kdf: [],
    pqc: [],
  };

  // Define keywords for fallback categorization
  const keywordMap: { [key: string]: string[] } = {
    pqc: ['kyber', 'dilithium', 'falcon', 'sphincs', 'ntru', 'bike'],
    mac_kdf: ['hmac', 'cmac', 'pbkdf2', 'hkdf', 'argon', 'bcrypt', 'scrypt', 'gcm', 'ccm', 'chacha20', 'poly1305'],
    asymmetric: ['rsa', 'ecc', 'dsa', 'diffie-hellman', 'x25519', 'ed25519'],
    hash: ['sha', 'md5'],
    symmetric: ['aes', 'des', 'rc4', 'rc5', 'blowfish', 'camellia', 'seed'],
  };

  transformedData.forEach(item => {
    // Primary categorization using the 'Section' field from the API
    const section = item.section?.toLowerCase() || '';
    if (section.includes('asymmetric')) {
      categories.asymmetric.push(item);
    } else if (section.includes('symmetric')) {
      categories.symmetric.push(item);
    } else if (section.includes('hash')) {
      categories.hash.push(item);
    } else if (section.includes('mac') || section.includes('kdf')) {
      categories.mac_kdf.push(item);
    } else if (section.includes('post-quantum')) {
      categories.pqc.push(item);
    } else {
      // Fallback to keyword-based categorization if 'Section' is not helpful
      const name = item.algorithm_name.toLowerCase();
      let found = false;
      for (const category in keywordMap) {
        if (keywordMap[category].some(keyword => name.includes(keyword))) {
          categories[category as keyof typeof categories].push(item);
          found = true;
          break;
        }
      }
      if (!found) {
        console.warn(`Could not categorize: ${item.algorithm_name}`);
        // Optionally add to a default/unknown category
      }
    }
  });

  return categories;
};

// Status badge component
const StatusBadge = ({ status }: { status: string }) => {
  const getBadgeClass = (status: string): string => {
    switch (status.toLowerCase()) {
      // General Status
      case "strong":
      case "safe":
      case "standardized":
      case "yes":
      case "low":
        return "bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300";
      case "medium":
      case "candidate":
        return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300";
      case "weak":
      case "high":
        return "bg-orange-100 text-orange-800 dark:bg-orange-900/50 dark:text-orange-300";
      case "insecure":
      case "no":
        return "bg-red-100 text-red-800 dark:bg-red-900/50 dark:text-red-300";
      
      // Priority
      case "high":
        return "bg-red-100 text-red-800 dark:bg-red-900/50 dark:text-red-300";
      // medium is handled above
      // low is handled above

      default:
        return "bg-muted text-muted-foreground";
    }
  };

  return (
    <Badge className={`text-xs border-transparent ${getBadgeClass(status)}`}>
      {status}
    </Badge>
  );
};

// Editable cell component
const EditableCell = ({
  value,
  columnKey
}: {
  value: string;
  columnKey: string;
}) => {
  const columnsWithBadges = [
    'status_today', 
    'pqc_status', 
    'priority', 
    'classical_recommended', 
    'quantum_recommended'
  ];
  if (columnsWithBadges.includes(columnKey)) {
    return <StatusBadge status={value} />;
  }

  return Array.isArray(value) ? (
    <span className="text-sm">{value.join(', ')}</span>
  ) : (
    <span className="text-sm">{value}</span>
  );
};

// Column definition interface
interface ColumnDef {
  key: string;
  header: string;
}

// Generic editable table component with persistence
const EditableTable = ({
  title,
  description,
  data,
  columns,
  onBack,
}: {
  title: string;
  description: string;
  data: any[];
  columns: ColumnDef[];
  onBack: () => void;
}) => {
  const [tableData, setTableData] = useState<any[]>(data);
  useEffect(() => setTableData(data), [data]);

  return (
    <motion.div
      initial={{ opacity: 0, x: 20 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: -20 }}
      transition={{ duration: 0.3 }}
      className="w-full"
    >
      <Card className="w-full">
        <CardHeader className="pb-4">
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
            <div className="flex items-center gap-3">
              <Button
                onClick={onBack}
                variant="outline"
                size="sm"
                className="flex items-center gap-2"
              >
                <ArrowLeft className="h-4 w-4" />
                Back
              </Button>
              <div>
                <div className="flex items-center gap-2">
                  <CardTitle className="text-lg font-semibold">{title}</CardTitle>
                </div>
                <CardDescription className="text-sm text-muted-foreground">
                  {description}
                </CardDescription>
              </div>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <div className="overflow-x-auto">
            <table className="w-full border-collapse">
              <thead>
                <tr className="border-b">
                  {columns.map((column) => (
                    <th key={column.key} className="text-left p-2 font-medium min-w-32">
                      {column.header}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {tableData.map((item) => (
                  <tr key={item.id} className="border-b hover:bg-muted/50 transition-colors">
                    {columns.map((column) => (
                      <td key={column.key} className="p-2 align-top">
                        <EditableCell
                          value={item[column.key] || ""}
                          columnKey={column.key}
                        />
                      </td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </CardContent>
      </Card>
    </motion.div>
  );
};

// Table category card component
const TableCategoryCard = ({
  title,
  description,
  icon: Icon,
  onClick,
  dataCount,
}: {
  title: string;
  description: string;
  icon: any;
  onClick: () => void;
  dataCount: number;
}) => {
  return (
    <motion.div
      whileHover={{ scale: 1.02, y: -2 }}
      whileTap={{ scale: 0.98 }}
      transition={{ duration: 0.2 }}
    >
      <Card 
        className="cursor-pointer hover:shadow-lg transition-all duration-200 border-2 hover:border-primary/20"
        onClick={onClick}
      >
        <CardHeader className="pb-3">
          <div className="flex items-center gap-3">
            <div className="p-2 rounded-lg bg-primary/10">
              <Icon className="h-5 w-5 text-primary" />
            </div>
            <div className="flex-1">
              <CardTitle className="text-lg font-semibold">{title}</CardTitle>
              <CardDescription className="text-sm">
                {description}
              </CardDescription>
            </div>
            <Badge variant="outline" className="text-xs">
              {dataCount} {dataCount === 1 ? 'item' : 'items'}
            </Badge>
          </div>
        </CardHeader>
      </Card>
    </motion.div>
  );
};

// Main dashboard component
const Dashboard = ({
  onTableSelect,
  symmetricData,
  asymmetricData,
  hashData,
  macKdfData,
  pqcData,
}: {
  onTableSelect: (tableType: string) => void;
  symmetricData: any[];
  asymmetricData: any[];
  hashData: any[];
  macKdfData: any[];
  pqcData: any[];
}) => {
  const tableCategories = [
    {
      id: 'symmetric',
      title: 'Symmetric Algorithms',
      description: 'Configure symmetric encryption algorithms and their settings',
      icon: Shield,
      dataCount: symmetricData.length,
    },
    {
      id: 'asymmetric',
      title: 'Asymmetric Algorithms',
      description: 'Configure asymmetric encryption and key exchange algorithms',
      icon: Key,
      dataCount: asymmetricData.length,
    },
    {
      id: 'hash',
      title: 'Hash Functions',
      description: 'Configure cryptographic hash functions and their parameters',
      icon: Hash,
      dataCount: hashData.length,
    },
    {
      id: 'mac_kdf',
      title: 'MACs & KDFs',
      description: 'Configure Message Authentication Codes and Key Derivation Functions',
      icon: Lock,
      dataCount: macKdfData.length,
    },
    {
      id: 'pqc',
      title: 'Post-Quantum Cryptography',
      description: 'Configure post-quantum cryptographic algorithms',
      icon: Cpu,
      dataCount: pqcData.length,
    },
  ];

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      transition={{ duration: 0.3 }}
      className="container mx-auto px-4 py-6 space-y-8 max-w-4xl"
    >
      <div className="text-center mb-12">
        <h1 className="text-4xl font-bold tracking-tight mb-4">Crypto Profile Manager</h1>
        <p className="text-lg text-muted-foreground max-w-2xl mx-auto"></p>
      </div>

      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-1 max-w-3xl mx-auto">
        {tableCategories.map((category) => (
          <TableCategoryCard
            key={category.id}
            title={category.title}
            description={category.description}
            icon={category.icon}
            dataCount={category.dataCount}
            onClick={() => onTableSelect(category.id)}
          />
        ))}
      </div>
    </motion.div>
  );
};

export const VulnerabilityCategoryTable = () => {
  const [symmetricData, setSymmetricData] = useState<CryptoAlgorithm[]>([]);
  const [asymmetricData, setAsymmetricData] = useState<CryptoAlgorithm[]>([]);
  const [hashData, setHashData] = useState<CryptoAlgorithm[]>([]);
  const [macKdfData, setMacKdfData] = useState<CryptoAlgorithm[]>([]);
  const [pqcData, setPqcData] = useState<CryptoAlgorithm[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [currentView, setCurrentView] = useState<'dashboard' | string>('dashboard');

  const [initialData, setInitialData] = useState<{ [key: string]: CryptoAlgorithm[] }>({});

  // Initialize all data from storage or use defaults
  useEffect(() => {
    const initializeData = async () => {
      try {
        const apiData = await fetchDataFromAPI();
        const transformedData = transformApiData(apiData);
        const categorizedData = categorizeApiData(transformedData);

        setInitialData(categorizedData);

        setSymmetricData(categorizedData.symmetric || []);
        setAsymmetricData(categorizedData.asymmetric || []);
        setHashData(categorizedData.hash || []);
        setMacKdfData(categorizedData.mac_kdf || []);
        setPqcData(categorizedData.pqc || []);
        
        console.log('🚀 Profile data initialized from storage');
      } catch (error) {
        console.error('❌ Error initializing profile data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    initializeData();
  }, []); // Empty dependency array ensures this runs only once on mount

  const commonColumns: ColumnDef[] = [
    { key: "algorithm_name", header: "Algorithm" },
    { key: "variant", header: "Variant" },
    { key: "purpose", header: "Purpose" },
    { key: "priority", header: "Priority" },
    { key: "usage_context", header: "Usage Context" },
    { key: "status_today", header: "Status" },
    { key: "pqc_status", header: "PQC Status" },
    { key: "classical_recommended", header: "Classical Rec." },
    { key: "quantum_recommended", header: "Quantum Rec." },
    { key: "nist_reference", header: "NIST Reference" },
    { key: "notes", header: "Notes" },
  ];

  const handleTableSelect = (tableType: string) => {
    setCurrentView(tableType);
  };

  const handleBackToDashboard = () => {
    setCurrentView('dashboard');
  };

  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-6 flex items-center justify-center min-h-screen">
        <div className="text-center">
          <RefreshCw className="h-8 w-8 animate-spin mx-auto mb-2 text-primary" />
          <p>Loading profile data...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background">
      <AnimatePresence mode="wait">
        {currentView === 'dashboard' ? (
          <Dashboard
            key="dashboard"
            onTableSelect={handleTableSelect}
            symmetricData={symmetricData}
            asymmetricData={asymmetricData}
            hashData={hashData}
            macKdfData={macKdfData}
            pqcData={pqcData}
          />
        ) : (
          <div key={currentView} className="container mx-auto px-4 py-6 space-y-8 max-w-full">
            {currentView === 'symmetric' && (
              <EditableTable
                title="Symmetric Algorithms"
                description="Configure symmetric encryption algorithms and their settings"
                data={initialData.symmetric || []}
                columns={commonColumns}
                onBack={handleBackToDashboard}
              />
            )}

            {currentView === 'asymmetric' && (
              <EditableTable
                title="Asymmetric Algorithms"
                description="Configure asymmetric encryption and key exchange algorithms"
                data={initialData.asymmetric || []}
                columns={commonColumns}
                onBack={handleBackToDashboard}
              />
            )}

            {currentView === 'hash' && (
              <EditableTable
                title="Hash Functions"
                description="Configure cryptographic hash functions and their parameters"
                data={initialData.hash || []}
                columns={commonColumns}
                onBack={handleBackToDashboard}
              />
            )}

            {currentView === 'mac_kdf' && (
              <EditableTable
                title="MACs & KDFs"
                description="Configure Message Authentication Codes and Key Derivation Functions"
                data={initialData.mac_kdf || []}
                columns={commonColumns}
                onBack={handleBackToDashboard}
              />
            )}

            {currentView === 'pqc' && (
              <EditableTable
                title="Post-Quantum Cryptography"
                description="Configure post-quantum cryptographic algorithms"
                data={initialData.pqc || []}
                columns={commonColumns}
                onBack={handleBackToDashboard}
              />
            )}
          </div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default VulnerabilityCategoryTable;