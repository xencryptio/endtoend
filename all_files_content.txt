
--- File: C:\Users\ASUS\Videos\xencrypt\db-service\crud.py ---
from sqlalchemy.orm import Session
from sqlalchemy import func
from typing import List, Optional, Tuple
import models
import schemas
from data_extractor import extract_all_normalized_fields


# ============================================================
# SCAN BATCH OPERATIONS
# ============================================================

def create_scan_batch(db: Session, batch: schemas.ScanBatchCreate) -> models.ScanBatch:
    """Create a new scan batch."""
    db_batch = models.ScanBatch(**batch.model_dump())
    db.add(db_batch)
    db.commit()
    db.refresh(db_batch)
    return db_batch


def get_scan_batch(db: Session, batch_id: str) -> Optional[models.ScanBatch]:
    """Get a scan batch by its batch_id."""
    return db.query(models.ScanBatch).filter(
        models.ScanBatch.batch_id == batch_id
    ).first()


def get_scan_batches(
    db: Session,
    skip: int = 0,
    limit: int = 100
) -> List[models.ScanBatch]:
    """Get all scan batches with pagination."""
    return db.query(models.ScanBatch).order_by(
        models.ScanBatch.created_at.desc()
    ).offset(skip).limit(limit).all()


def update_scan_batch_status(
    db: Session,
    batch_id: str,
    status: str,
    successful_count: int = None,
    failed_count: int = None
) -> Optional[models.ScanBatch]:
    """Update scan batch status and counts."""
    batch = get_scan_batch(db, batch_id)
    if batch:
        batch.status = status
        if successful_count is not None:
            batch.successful_count = successful_count
        if failed_count is not None:
            batch.failed_count = failed_count
        db.commit()
        db.refresh(batch)
    return batch


def delete_scan_batch_completely(db: Session, batch_id: str) -> bool:
    """Delete a scan batch and ALL its associated results from database."""
    try:
        batch_to_delete = db.query(models.ScanBatch).filter(
            models.ScanBatch.batch_id == batch_id
        ).first()
        if not batch_to_delete:
            return False

        db.delete(batch_to_delete)
        db.commit()
        return True
    except Exception as e:
        db.rollback()
        print(f"Error deleting batch {batch_id}: {e}")
        return False


# ============================================================
# SCAN RESULT OPERATIONS
# ============================================================

def create_scan_result(
    db: Session,
    scan: schemas.ScanResultCreate
) -> models.ScanResult:
    """Create a new scan result and extract normalized fields."""
    scan_data = scan.model_dump()

    print(f"\n{'='*60}")
    print(f"ðŸ“¥ DB-SERVICE: Creating scan result")
    print(f"   URL: {scan_data.get('url')}")
    print(f"   Status: {scan_data.get('status')}")
    print(f"   Has raw_response: {bool(scan_data.get('raw_response'))}")

    raw_response = scan_data.get("raw_response")
    if raw_response:
        print(f"   ðŸ” Extracting normalized fields...")
        print(f"   Raw response keys: {list(raw_response.keys())}")
        try:
            normalized_fields = extract_all_normalized_fields(raw_response)
            print(f"   âœ… Extracted {len(normalized_fields)} normalized fields")
            print(f"   PQC Score: {normalized_fields.get('pqc_overall_score')}")
            print(f"   PQC Grade: {normalized_fields.get('pqc_overall_grade')}")

            # Update scan_data with normalized fields
            scan_data.update(normalized_fields)
        except Exception as e:
            print(f"   âš ï¸ Error extracting normalized fields: {e}")
    else:
        print(f"   âš ï¸ No raw_response provided!")

    # Remove deprecated fields
    if 'quantum_score' in scan_data:
        print(f"   ðŸ—‘ï¸ Removing quantum_score (replaced with pqc_overall_score)")
        del scan_data['quantum_score']
    if 'quantum_grade' in scan_data:
        print(f"   ðŸ—‘ï¸ Removing quantum_grade (replaced with pqc_overall_grade)")
        del scan_data['quantum_grade']

    try:
        db_scan = models.ScanResult(**scan_data)
        db.add(db_scan)
        db.commit()
        db.refresh(db_scan)

        print(f"   âœ… Saved to database with ID: {db_scan.id}")
        print(f"   Stored PQC Score: {db_scan.pqc_overall_score}")
        print(f"   Stored PQC Grade: {db_scan.pqc_overall_grade}")
        print(f"{'='*60}\n")

        update_batch_counts(db, scan.batch_id)
        return db_scan

    except Exception as e:
        print(f"   âŒ Error creating database record: {e}")
        print(f"{'='*60}\n")
        db.rollback()
        raise


def get_scan_result(db: Session, result_id: int) -> Optional[models.ScanResult]:
    """Get a scan result by its ID."""
    return db.query(models.ScanResult).filter(
        models.ScanResult.id == result_id
    ).first()


def get_scan_results(
    db: Session,
    batch_id: Optional[str] = None,
    status: Optional[str] = None,
    skip: int = 0,
    limit: int = 100
) -> List[models.ScanResult]:
    """Get scan results with optional filtering."""
    query = db.query(models.ScanResult)
    if batch_id:
        query = query.filter(models.ScanResult.batch_id == batch_id)
    if status:
        query = query.filter(models.ScanResult.status == status)

    return query.order_by(
        models.ScanResult.requested_at.desc()
    ).offset(skip).limit(limit).all()


def update_scan_result(
    db: Session,
    result_id: int,
    **kwargs
) -> Optional[models.ScanResult]:
    """Update scan result (re-extract normalized fields if raw_response provided)."""
    result = get_scan_result(db, result_id)
    if not result:
        return None

    # If raw_response updated â†’ extract new normalized fields
    if "raw_response" in kwargs and kwargs["raw_response"]:
        try:
            normalized = extract_all_normalized_fields(kwargs["raw_response"])
            for key, value in normalized.items():
                if hasattr(result, key):
                    setattr(result, key, value)
        except Exception as e:
            print(f"âš ï¸ Error extracting normalized fields during update: {e}")

    # Remove deprecated fields
    if 'quantum_score' in kwargs:
        del kwargs['quantum_score']
    if 'quantum_grade' in kwargs:
        del kwargs['quantum_grade']

    # Apply field updates
    for key, value in kwargs.items():
        if hasattr(result, key):
            setattr(result, key, value)

    db.commit()
    db.refresh(result)
    update_batch_counts(db, result.batch_id)
    return result


def delete_single_scan_result(db: Session, result_id: int) -> bool:
    """Delete a single scan result and update batch counts."""
    try:
        result = db.query(models.ScanResult).filter(
            models.ScanResult.id == result_id
        ).first()
        if not result:
            return False

        batch_id = result.batch_id
        db.delete(result)
        db.commit()
        update_batch_counts(db, batch_id)
        return True
    except Exception as e:
        db.rollback()
        print(f"Error deleting result {result_id}: {e}")
        return False


# ============================================================
# BULK OPERATIONS
# ============================================================

def delete_all_scans(db: Session) -> Tuple[int, int]:
    """Delete all scan results and batches. Returns (results_deleted, batches_deleted)."""
    results_deleted = db.query(models.ScanResult).delete()
    batches_deleted = db.query(models.ScanBatch).delete()
    db.commit()
    return results_deleted, batches_deleted


# ============================================================
# HELPER FUNCTIONS
# ============================================================

def update_batch_counts(db: Session, batch_id: str):
    """Recalculate and update batch success/failure counts."""
    batch = get_scan_batch(db, batch_id)
    if batch:
        successful = db.query(models.ScanResult).filter(
            models.ScanResult.batch_id == batch_id,
            models.ScanResult.status == "completed"
        ).count()

        failed = db.query(models.ScanResult).filter(
            models.ScanResult.batch_id == batch_id,
            models.ScanResult.status == "failed"
        ).count()

        batch.successful_count = successful
        batch.failed_count = failed

        total = batch.total_urls
        if successful + failed == total:
            batch.status = "completed"
        elif failed == total:
            batch.status = "failed"
        else:
            batch.status = "in_progress"

        db.commit()


def get_scan_statistics(db: Session) -> dict:
    """Get database statistics."""
    total_batches = db.query(models.ScanBatch).count()
    total_results = db.query(models.ScanResult).count()

    successful = db.query(models.ScanResult).filter(
        models.ScanResult.status == "completed"
    ).count()

    failed = db.query(models.ScanResult).filter(
        models.ScanResult.status == "failed"
    ).count()

    pending = db.query(models.ScanResult).filter(
        models.ScanResult.status == "pending"
    ).count()

    avg_time = db.query(
        func.avg(models.ScanResult.execution_time_seconds)
    ).filter(
        models.ScanResult.execution_time_seconds.isnot(None)
    ).scalar()

    return {
        "total_batches": total_batches,
        "total_results": total_results,
        "successful_scans": successful,
        "failed_scans": failed,
        "pending_scans": pending,
        "avg_execution_time": round(float(avg_time), 2) if avg_time else None
    }


--- File: C:\Users\ASUS\Videos\xencrypt\db-service\database.py ---
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

# Get database URL from environment variable
DATABASE_URL = os.getenv(
    "DATABASE_URL", 
    "postgresql://scanuser:scanpass@postgres:5432/scandb"
)

print(f"ðŸ“¡ Using database URL: {DATABASE_URL}")  # Add this debug line

# Create SQLAlchemy engine
engine = create_engine(
    DATABASE_URL,
    pool_pre_ping=True,  # Verify connections before using
    pool_size=10,
    max_overflow=20
)

# Create session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()

# Dependency for FastAPI routes
def get_db():
    """
    Database session dependency.
    Yields a database session and closes it after use.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

--- File: C:\Users\ASUS\Videos\xencrypt\db-service\data_extractor.py ---
"""
Extract normalized fields from raw scan response
This utility extracts structured data from the raw JSON response
"""
from typing import Dict, Any, Optional
from datetime import datetime


def extract_pqc_fields(raw_response: Dict[str, Any]) -> Dict[str, Any]:
    """Extract PQC/Quantum fields from raw response."""
    pqc_analysis = raw_response.get("pqc_analysis", {})

    # ðŸ”§ FIX: Try multiple sources for scores
    # Priority: pqc_analysis > top-level quantum_* fields
    overall_score = None
    overall_grade = None

    # First try: pqc_analysis
    if pqc_analysis and isinstance(pqc_analysis, dict):
        overall_score = pqc_analysis.get("overall_score")
        overall_grade = pqc_analysis.get("overall_grade")

    # Fallback: top-level quantum fields
    if overall_score is None:
        overall_score = raw_response.get("quantum_score")
    if overall_grade is None:
        overall_grade = raw_response.get("quantum_grade")

    return {
        "pqc_overall_score": overall_score,
        "pqc_overall_grade": overall_grade,
        "pqc_security_level": pqc_analysis.get("security_level") if pqc_analysis else None,
        "pqc_quantum_ready": pqc_analysis.get("quantum_ready", False) if pqc_analysis else False,
        "pqc_hybrid_ready": pqc_analysis.get("hybrid_ready", False) if pqc_analysis else False,
    }


def extract_tls_fields(raw_response: Dict[str, Any]) -> Dict[str, Any]:
    """Extract TLS configuration fields from raw response."""
    tls_config = raw_response.get("tls_configuration", {})
    
    supported_protocols = tls_config.get("supported_protocols", [])
    protocols_str = ",".join(supported_protocols) if supported_protocols else None
    
    return {
        "tls_version": ", ".join(supported_protocols) if supported_protocols else None,
        "supported_protocols": protocols_str,
    }


def extract_kex_fields(raw_response: Dict[str, Any]) -> Dict[str, Any]:
    """Extract Key Exchange fields from raw response."""
    tls_config = raw_response.get("tls_configuration", {})
    
    kex_score = None
    kex_grade = None
    
    # Try TLS 1.2
    tls12_suites = tls_config.get("tls_1.2_cipher_suites", {})
    if isinstance(tls12_suites, dict):
        kex_score = tls12_suites.get("component_kex_score")
        kex_grade = tls12_suites.get("component_kex_grade")
    
    # Fallback to TLS 1.3
    if not kex_score:
        tls13_suites = tls_config.get("tls_1.3_cipher_suites", {})
        if isinstance(tls13_suites, dict):
            kex_score = tls13_suites.get("component_kex_score")
            kex_grade = tls13_suites.get("component_kex_grade")
    
    return {
        "kex_score": kex_score,
        "kex_grade": kex_grade,
    }


def extract_cipher_fields(raw_response: Dict[str, Any]) -> Dict[str, Any]:
    """Extract primary cipher suite from raw response."""
    tls_config = raw_response.get("tls_configuration", {})
    
    primary_cipher = None
    
    # Try TLS 1.3 first (preferred)
    tls13_suites = tls_config.get("tls_1.3_cipher_suites", {})
    if isinstance(tls13_suites, dict):
        suites = tls13_suites.get("suites", [])
        if suites and len(suites) > 0:
            primary_cipher = suites[0].get("name")
    
    # Fallback to TLS 1.2
    if not primary_cipher:
        tls12_suites = tls_config.get("tls_1.2_cipher_suites", {})
        if isinstance(tls12_suites, dict):
            suites = tls12_suites.get("suites", [])
            if suites and len(suites) > 0:
                primary_cipher = suites[0].get("name")
    
    return {
        "primary_cipher_suite": primary_cipher,
    }


def extract_certificate_fields(raw_response: Dict[str, Any]) -> Dict[str, Any]:
    """Extract certificate fields from raw response."""
    cert_chain = raw_response.get("certificate_chain", {})
    leaf_cert = cert_chain.get("leaf_certificate", {})
    
    return {
        "cert_pqc_score": leaf_cert.get("cert_pqc_score"),
        "cert_pqc_grade": leaf_cert.get("cert_pqc_grade"),
        "cert_is_pqc": leaf_cert.get("cert_is_pqc", False),
        "cert_transparency": leaf_cert.get("certificate_transparency", False),
    }


def extract_signature_fields(raw_response: Dict[str, Any]) -> Dict[str, Any]:
    """Extract signature algorithm fields from raw response."""
    sig_algorithms = raw_response.get("signature_algorithms", {})
    cert_sigs = sig_algorithms.get("certificate_signatures", [])
    
    primary_sig_algo = None
    primary_hash_algo = None
    
    if cert_sigs and len(cert_sigs) > 0:
        primary_sig_algo = cert_sigs[0].get("signature_algorithm")
        primary_hash_algo = cert_sigs[0].get("hash_algorithm")
    
    return {
        "primary_signature_algorithm": primary_sig_algo,
        "primary_hash_algorithm": primary_hash_algo,
    }


def extract_security_features(raw_response: Dict[str, Any]) -> Dict[str, Any]:
    """Extract security feature flags from raw response."""
    tls_config = raw_response.get("tls_configuration", {})
    
    # Determine if ephemeral key exchange is supported
    ephemeral_supported = False
    tls12_suites = tls_config.get("tls_1.2_cipher_suites", {})
    if isinstance(tls12_suites, dict):
        for suite in tls12_suites.get("suites", []):
            if "ECDHE" in suite.get("key_exchange", ""):
                ephemeral_supported = True
                break
    
    return {
        "ephemeral_key_exchange": ephemeral_supported,
        "ct_present": raw_response.get("ct_present", False),
    }


def extract_all_normalized_fields(raw_response: Dict[str, Any]) -> Dict[str, Any]:
    """Extract ALL normalized fields from raw response."""
    
    fields = {}
    
    # Extract each category
    fields.update(extract_pqc_fields(raw_response))
    fields.update(extract_tls_fields(raw_response))
    fields.update(extract_kex_fields(raw_response))
    fields.update(extract_cipher_fields(raw_response))
    fields.update(extract_certificate_fields(raw_response))
    fields.update(extract_signature_fields(raw_response))
    fields.update(extract_security_features(raw_response))
    
    return fields

--- File: C:\Users\ASUS\Videos\xencrypt\db-service\Dockerfile ---
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies including curl for healthcheck
RUN apt-get update && apt-get install -y \
    postgresql-client \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose port
EXPOSE 8001

# Run the application
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8001"]

--- File: C:\Users\ASUS\Videos\xencrypt\db-service\main.py ---
from fastapi import FastAPI, HTTPException, Depends, Body
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from sqlalchemy import text
from typing import List, Optional
from datetime import datetime
import models
import schemas
import crud
from database import engine, get_db

# Create database tables on startup
try:
    models.Base.metadata.create_all(bind=engine)
    print("âœ… Database tables created/verified")
except Exception as e:
    print(f"âš ï¸ Error creating tables: {e}")


app = FastAPI(title="Scan Storage Service", version="1.0")

# CORS Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ============================================================
# SCAN BATCH ENDPOINTS (Multiple URLs in one scan request)
# ============================================================

@app.post("/scans/batch", response_model=schemas.ScanBatch)
def create_scan_batch(
    batch: schemas.ScanBatchCreate, 
    db: Session = Depends(get_db)
):
    """
    Create a new scan batch (represents one scan request with multiple URLs).
    Returns the created batch with a unique batch_id.
    """
    return crud.create_scan_batch(db, batch)

@app.get("/scans/batch", response_model=List[schemas.ScanBatch])
def get_all_scan_batches(
    skip: int = 0, 
    limit: int = 100, 
    db: Session = Depends(get_db)
):
    """
    Get all scan batches with pagination.
    """
    return crud.get_scan_batches(db, skip=skip, limit=limit)

@app.get("/scans/batch/{batch_id}", response_model=schemas.ScanBatchWithNormalizedResults)
def get_scan_batch_by_id(batch_id: str, db: Session = Depends(get_db)):
    """
    Get a specific scan batch with all its scan results.
    
    Each result includes:
    - Normalized fields for fast filtering/display
    - raw_response for complete technical details
    """
    batch = crud.get_scan_batch(db, batch_id)
    if not batch:
        raise HTTPException(status_code=404, detail="Scan batch not found")
    
    # Convert results to normalized schema
    normalized_results = [
        schemas.ScanResultWithNormalized.from_orm(r) 
        for r in batch.scan_results
    ]
    
    return schemas.ScanBatchWithNormalizedResults.from_orm(batch)

@app.delete("/scans/batch/{batch_id}")
def delete_scan_batch_endpoint(batch_id: str, db: Session = Depends(get_db)):
    """
    Delete a scan batch and all its associated scan results.
    """
    success = crud.delete_scan_batch_completely(db, batch_id)
    if not success:
        raise HTTPException(status_code=404, detail="Scan batch not found or already deleted")
    return {
        "message": "Scan batch and all its results deleted successfully",
        "batch_id": batch_id
    }

@app.put("/scans/batch/{batch_id}", response_model=schemas.ScanBatch)
def update_scan_batch(
    batch_id: str,
    batch: schemas.ScanBatchUpdate,
    db: Session = Depends(get_db)
):
    """
    Update a scan batch's status and counts.
    """
    updated_batch = crud.update_scan_batch_status(
        db,
        batch_id=batch_id,
        status=batch.status,
        successful_count=batch.successful_count,
        failed_count=batch.failed_count
    )
    if not updated_batch:
        raise HTTPException(status_code=404, detail="Scan batch not found")
    return updated_batch

# ============================================================
# INDIVIDUAL SCAN RESULT ENDPOINTS
# ============================================================

@app.post("/scans/result", response_model=schemas.ScanResult)
def create_scan_result(
    scan: schemas.ScanResultCreate, 
    db: Session = Depends(get_db)
):
    """
    Store a single scan result (linked to a batch_id).
    """
    return crud.create_scan_result(db, scan)

@app.get("/scans/results", response_model=List[schemas.ScanResultWithNormalized])
def get_all_scan_results(
    batch_id: Optional[str] = None,
    status: Optional[str] = None,
    skip: int = 0, 
    limit: int = 100, 
    db: Session = Depends(get_db)
):
    """
    Get all scan results with optional filtering.
    
    Query by normalized fields:
    - ?status=completed
    - ?batch_id=batch_123
    
    Returns normalized fields + raw_response for each result.
    """
    results = crud.get_scan_results(db, batch_id=batch_id, status=status, skip=skip, limit=limit)
    return [schemas.ScanResultWithNormalized.from_orm(r) for r in results]

@app.get("/scans/result/{result_id}", response_model=schemas.ScanResultWithNormalized)
def get_scan_result_by_id(result_id: int, db: Session = Depends(get_db)):
    """
    Get a specific scan result by its ID.
    
    Returns:
    - Normalized queryable fields (pqc_grade, kex_score, tls_version, etc.)
    - raw_response: Complete JSON audit trail
    
    Frontend receives BOTH - uses normalized fields for display,
    raw_response for drill-down and detailed analysis.
    """
    result = crud.get_scan_result(db, result_id)
    if not result:
        raise HTTPException(status_code=404, detail="Scan result not found")
    return result

@app.delete("/scans/result/{result_id}")
def delete_individual_scan_result(result_id: int, db: Session = Depends(get_db)):
    """
    Delete a single scan result.
    The batch counts will be automatically updated.
    """
    success = crud.delete_single_scan_result(db, result_id)
    if not success:
        raise HTTPException(status_code=404, detail="Scan result not found or already deleted")
    return {
        "message": "Scan result deleted successfully",
        "result_id": result_id
    }

@app.get("/scans/search", response_model=List[schemas.ScanResultWithNormalized])
def search_scan_results(
    pqc_grade: Optional[str] = None,  # Filter by PQC grade: A+, A, B, etc.
    quantum_ready: Optional[bool] = None,  # Only quantum-ready scans
    tls_version: Optional[str] = None,  # Filter by TLS version: TLS 1.3
    status: Optional[str] = None,
    limit: int = 100,
    db: Session = Depends(get_db)
):
    """
    Search scan results using normalized fields.
    
    Examples:
    - /scans/search?pqc_grade=A&quantum_ready=true
    - /scans/search?tls_version=TLS%201.3
    - /scans/search?status=completed
    
    Uses normalized DB columns for efficient queries.
    Returns results with both normalized fields AND raw_response.
    """
    query = db.query(models.ScanResult)
    
    # Filter by normalized fields
    if pqc_grade:
        query = query.filter(models.ScanResult.pqc_overall_grade == pqc_grade)
    
    if quantum_ready is not None:
        query = query.filter(models.ScanResult.pqc_quantum_ready == quantum_ready)
    
    if tls_version:
        # Use contains for flexible matching (e.g., "TLS 1.3" in "TLS 1.2, TLS 1.3")
        query = query.filter(models.ScanResult.tls_version.ilike(f"%{tls_version}%"))
    
    if status:
        query = query.filter(models.ScanResult.status == status)
    
    results = query.order_by(
        models.ScanResult.completed_at.desc().nulls_last()
    ).limit(limit).all()
    
    # Use from_orm to convert each SQLAlchemy model instance to a Pydantic model
    return [schemas.ScanResultWithNormalized.from_orm(r) for r in results]


# ============================================================
# BULK OPERATIONS
# ============================================================

@app.delete("/scans/clear-all")
def clear_all_data(db: Session = Depends(get_db)):
    """
    DANGER: Delete ALL scan batches and results from database.
    This operation cannot be undone.
    """
    try:
        # Delete in correct order: results first, then batches
        deleted_results = db.query(models.ScanResult).delete()
        deleted_batches = db.query(models.ScanBatch).delete()
        
        db.commit()
        
        return {
            "message": "All data cleared successfully from database",
            "deleted_results": deleted_results,
            "deleted_batches": deleted_batches,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=500, 
            detail=f"Error clearing data: {str(e)}"
        )

@app.get("/scans/stats")
def get_scan_statistics(db: Session = Depends(get_db)):
    """
    Get database statistics using normalized fields.
    
    Efficiently queries normalized columns (no JSON parsing needed).
    """
    total_batches = db.query(models.ScanBatch).count()
    total_results = db.query(models.ScanResult).count()
    
    # Query normalized fields efficiently
    successful = db.query(models.ScanResult).filter(
        models.ScanResult.status == "completed"
    ).count()
    
    failed = db.query(models.ScanResult).filter(
        models.ScanResult.status == "failed"
    ).count()
    
    pending = db.query(models.ScanResult).filter(
        models.ScanResult.status == "pending"
    ).count()
    
    # Quantum ready statistics
    quantum_ready = db.query(models.ScanResult).filter(
        models.ScanResult.pqc_quantum_ready == True
    ).count()
    
    # Average scores using normalized fields
    from sqlalchemy import func
    avg_pqc = db.query(func.avg(models.ScanResult.pqc_overall_score)).filter(
        models.ScanResult.pqc_overall_score.isnot(None)
    ).scalar()
    
    avg_execution = db.query(func.avg(models.ScanResult.execution_time_seconds)).filter(
        models.ScanResult.execution_time_seconds.isnot(None)
    ).scalar()
    
    return crud.get_scan_statistics(db)

# Optional: Add endpoint to get batch with all its results (useful for detail views)

@app.get("/scans/batch/{batch_id}/with-results")
def get_batch_with_results(batch_id: str, db: Session = Depends(get_db)):
    """
    Get a batch with all its associated results.
    Useful for detail pages.
    """
    batch = crud.get_scan_batch(db, batch_id)
    if not batch:
        raise HTTPException(status_code=404, detail="Batch not found")
    
    return {
        "batch": batch,
        "results": batch.scan_results if batch.scan_results else []
    }

# ============================================================
# HEALTH CHECK
# ============================================================

@app.get("/health")
def health_check(db: Session = Depends(get_db)):
    """
    Check if service and database are healthy.
    """
    try:
        # Create all tables first (idempotent operation)
        models.Base.metadata.create_all(bind=engine)
        
        # Test database connection with a simple query
        result = db.execute(text("SELECT 1"))
        db.commit()
        
        return {
            "status": "healthy",
            "database": "connected",
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        print(f"Health check error: {str(e)}")
        raise HTTPException(
            status_code=503, 
            detail=f"Database connection failed: {str(e)}"
        )

@app.get("/")
def root():
    """
    API root endpoint with documentation.
    """
    return {
        "service": "Scan Storage Service",
        "version": "1.0",
        "description": "Persistent storage for crypto scan results",
        "endpoints": {
            "POST /scans/batch": "Create a new scan batch",
            "GET /scans/batch": "Get all scan batches",
            "GET /scans/batch/{batch_id}": "Get specific batch with results",
            "DELETE /scans/batch/{batch_id}": "Delete a batch and its results",
            "POST /scans/result": "Store a single scan result",
            "GET /scans/result": "Get all scan results (filter by batch_id/status)",
            "GET /scans/search": "Search results by normalized fields (pqc_grade, etc.)",
            "GET /scans/result/{result_id}": "Get specific scan result",
            "DELETE /scans/result/{result_id}": "Delete a scan result",
            "DELETE /scans/clear-all": "Clear ALL data (dangerous)",
            "GET /scans/stats": "Get database statistics",
            "GET /health": "Health check"
        }
    }

--- File: C:\Users\ASUS\Videos\xencrypt\db-service\models.py ---
from sqlalchemy import Column, Integer, String, DateTime, Text, ForeignKey, JSON, Float, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base

class ScanBatch(Base):
    """
    Represents a single scan request (can contain multiple URLs).
    Each batch has a unique batch_id.
    """
    __tablename__ = "scan_batches"

    id = Column(Integer, primary_key=True, index=True)
    batch_id = Column(String(100), unique=True, index=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    total_urls = Column(Integer, default=0)
    successful_count = Column(Integer, default=0)
    failed_count = Column(Integer, default=0)
    status = Column(String(50), default="pending")
    max_concurrent = Column(Integer, default=5)
    
    # Relationship to scan results
    scan_results = relationship("ScanResult", back_populates="batch", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<ScanBatch(batch_id={self.batch_id}, total_urls={self.total_urls}, status={self.status})>"


class ScanResult(Base):
    """
    Represents a single URL scan result with normalized structured fields.
    """
    __tablename__ = "scan_results"

    id = Column(Integer, primary_key=True, index=True)
    batch_id = Column(String(100), ForeignKey("scan_batches.batch_id"), nullable=False, index=True)
    request_id = Column(String(100), unique=True, index=True)
    url = Column(Text, nullable=False, index=True)
    status = Column(String(50), default="pending")
    scan_type = Column(String(100), default="crypto_audit")
    
    # Timestamps
    requested_at = Column(DateTime(timezone=True))
    completed_at = Column(DateTime(timezone=True))
    execution_time_seconds = Column(Float)
    
    # ============================================================
    # PQC/Quantum Fields (Structured - Queryable)
    # ============================================================
    pqc_overall_score = Column(Float)
    pqc_overall_grade = Column(String(5))
    pqc_security_level = Column(String(50))
    pqc_quantum_ready = Column(Boolean, default=False)
    pqc_hybrid_ready = Column(Boolean, default=False)
    
    # ============================================================
    # TLS Configuration Fields (Structured - Queryable)
    # ============================================================
    tls_version = Column(String(200))
    supported_protocols = Column(String(500))
    primary_cipher_suite = Column(String(255))
    
    # ============================================================
    # Key Exchange Fields (Structured - Queryable)
    # ============================================================
    kex_score = Column(Float)
    kex_grade = Column(String(5))
    
    # ============================================================
    # Certificate Fields (Structured - Queryable)
    # ============================================================
    cert_pqc_score = Column(Float)
    cert_pqc_grade = Column(String(5))
    cert_is_pqc = Column(Boolean, default=False)
    cert_transparency = Column(Boolean, default=False)
    cert_subject = Column(String(255))
    cert_issuer = Column(String(255))
    cert_serial_number = Column(String(255))
    cert_not_before = Column(DateTime)
    cert_not_after = Column(DateTime)
    
    # ============================================================
    # Signature Algorithm Fields (Structured - Queryable)
    # ============================================================
    primary_signature_algorithm = Column(String(100))
    primary_hash_algorithm = Column(String(100))
    
    # ============================================================
    # Security Features (Structured - Queryable)
    # ============================================================
    public_key_algorithm = Column(String(100))
    public_key_size_bits = Column(Integer)
    ephemeral_key_exchange = Column(Boolean, default=False)
    hsts_enabled = Column(Boolean, default=False)
    ocsp_stapling_active = Column(Boolean, default=False)
    ct_present = Column(Boolean, default=False)
    
    # Error information
    error_message = Column(Text)
    
    # Full raw response (JSON backup - NOT for queries, only for audit/reference)
    raw_response = Column(JSON)
    
    # Relationship to batch
    batch = relationship("ScanBatch", back_populates="scan_results")

    def __repr__(self):
        return f"<ScanResult(url={self.url}, status={self.status}, pqc_grade={self.pqc_overall_grade})>"

--- File: C:\Users\ASUS\Videos\xencrypt\db-service\requirements.txt ---
fastapi==0.109.0
uvicorn[standard]==0.27.0
sqlalchemy==2.0.25
psycopg2-binary==2.9.9
pydantic==2.5.3
python-multipart==0.0.6

--- File: C:\Users\ASUS\Videos\xencrypt\db-service\schemas.py ---
from __future__ import annotations

from pydantic import BaseModel, Field, validator
from typing import Optional, List, Dict, Any
from datetime import datetime

# ============================================================
# SCAN BATCH SCHEMAS
# ============================================================

class ScanBatchBase(BaseModel):
    batch_id: str
    total_urls: int = 0
    max_concurrent: int = 5

class ScanBatchCreate(ScanBatchBase):
    status: str = "pending"

class ScanBatch(ScanBatchBase):
    id: int
    created_at: datetime
    successful_count: int = 0
    failed_count: int = 0
    status: str

    class Config:
        from_attributes = True

class ScanBatchUpdate(BaseModel):
    status: Optional[str] = None
    successful_count: Optional[int] = None
    failed_count: Optional[int] = None
    updated_at: Optional[datetime] = None

class ScanBatchWithResults(ScanBatch):
    """Batch with all its scan results included"""
    scan_results: List["ScanResult"] = []

    class Config:
        from_attributes = True

# ============================================================
# SCAN RESULT SCHEMAS
# ============================================================

class ScanResultBase(BaseModel):
    batch_id: str
    url: str
    scan_type: str = "crypto_audit"

class ScanResultCreate(ScanResultBase):
    request_id: Optional[str] = None
    status: str = "pending"
    requested_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    execution_time_seconds: Optional[float] = None
    tls_version: Optional[str] = None
    primary_cipher_suite: Optional[str] = None
    quantum_score: Optional[float] = None
    quantum_grade: Optional[str] = None
    raw_response: Optional[Dict[str, Any]] = None
    error_message: Optional[str] = None

    # ðŸ”§ FIX: Validator to ensure raw_response is always present and contains pqc_analysis
    @validator('raw_response', always=True)
    def validate_raw_response(cls, v, values):
        """Ensure we have minimum data to store."""
        if not v:
            # If no raw_response, create a minimal structure from available fields
            url = values.get("url", "")
            quantum_score = values.get("quantum_score")
            quantum_grade = values.get("quantum_grade")
            tls_version = values.get("tls_version")

            return {
                "domain": url,
                "quantum_score": quantum_score,
                "quantum_grade": quantum_grade,
                "tls_configuration": {
                    "supported_protocols": [tls_version] if tls_version else []
                },
                # ðŸ”§ ADD: Include pqc_analysis structure
                "pqc_analysis": {
                    "overall_score": quantum_score,
                    "overall_grade": quantum_grade,
                    "security_level": "unknown",
                    "quantum_ready": False,
                    "hybrid_ready": False
                } if quantum_score is not None else {}
            }

        # ðŸ”§ FIX: Ensure pqc_analysis exists in raw_response
        if isinstance(v, dict) and "pqc_analysis" not in v:
            quantum_score = v.get("quantum_score") or values.get("quantum_score")
            quantum_grade = v.get("quantum_grade") or values.get("quantum_grade")
            if quantum_score is not None:
                v["pqc_analysis"] = {
                    "overall_score": quantum_score,
                    "overall_grade": quantum_grade,
                    "security_level": "unknown",
                    "quantum_ready": False,
                    "hybrid_ready": False
                }
        return v

class ScanResult(ScanResultBase):
    id: int
    request_id: Optional[str] = None
    status: str
    requested_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    execution_time_seconds: Optional[float] = None
    tls_version: Optional[str] = None
    primary_cipher_suite: Optional[str] = None
    quantum_score: Optional[float] = None
    quantum_grade: Optional[str] = None
    raw_response: Optional[Dict[str, Any]] = None
    error_message: Optional[str] = None

    class Config:
        from_attributes = True

# Update forward reference
ScanBatchWithResults.model_rebuild()

# ============================================================
# STATISTICS SCHEMA
# ============================================================

class ScanStatistics(BaseModel):
    total_batches: int
    total_results: int
    successful_scans: int
    failed_scans: int
    pending_scans: int
    avg_execution_time: Optional[float] = None


class DeleteResponse(BaseModel):
    message: str
    batch_id: Optional[str] = None
    result_id: Optional[int] = None
    deleted_count: Optional[int] = None
    timestamp: Optional[str] = None
    
    class Config:
        from_attributes = True


class ScanResultWithNormalized(BaseModel):
    """
    Enhanced scan result schema that combines:
    1. Normalized queryable fields (stored separately in DB)
    2. Raw JSON response (for complete audit trail)
    
    When sent to frontend: includes BOTH for backward compatibility
    """
    id: int
    batch_id: str
    request_id: Optional[str] = None
    url: str
    status: str
    scan_type: str
    
    # Timestamps
    requested_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    execution_time_seconds: Optional[float] = None
    
    # ============================================================
    # Normalized Fields (Queryable in DB)
    # ============================================================
    
    # PQC Fields
    pqc_overall_score: Optional[float] = None
    pqc_overall_grade: Optional[str] = None
    pqc_security_level: Optional[str] = None
    pqc_quantum_ready: Optional[bool] = None
    pqc_hybrid_ready: Optional[bool] = None
    
    # TLS Fields
    tls_version: Optional[str] = None
    supported_protocols: Optional[str] = None
    
    # KEX Fields
    kex_score: Optional[float] = None
    kex_grade: Optional[str] = None
    
    # Cipher Fields
    primary_cipher_suite: Optional[str] = None
    
    # Certificate Fields
    cert_pqc_score: Optional[float] = None
    cert_pqc_grade: Optional[str] = None
    cert_is_pqc: Optional[bool] = None
    cert_transparency: Optional[bool] = None
    cert_subject: Optional[str] = None
    cert_issuer: Optional[str] = None
    cert_serial_number: Optional[str] = None
    cert_not_before: Optional[datetime] = None
    cert_not_after: Optional[datetime] = None
    
    # Signature Fields
    primary_signature_algorithm: Optional[str] = None
    primary_hash_algorithm: Optional[str] = None
    
    # Security Features
    public_key_algorithm: Optional[str] = None
    public_key_size_bits: Optional[int] = None
    ephemeral_key_exchange: Optional[bool] = None
    hsts_enabled: Optional[bool] = None
    ocsp_stapling_active: Optional[bool] = None
    ct_present: Optional[bool] = None
    
    # Error
    error_message: Optional[str] = None
    
    # ============================================================
    # Raw Response (Complete Audit Trail)
    # ============================================================
    raw_response: Optional[Dict[str, Any]] = None
    
    class Config:
        from_attributes = True


class ScanBatchWithNormalizedResults(ScanBatch):
    """Batch with all its scan results (with normalized fields)."""
    scan_results: List[ScanResultWithNormalized] = []
    
    class Config:
        from_attributes = True


class ClearAllResponse(BaseModel):
    message: str
    deleted_results: int
    deleted_batches: int
    timestamp: str
    
    class Config:
        from_attributes = True

--- File: C:\Users\ASUS\Videos\xencrypt\Frontend\src\components\scan\ResultsDetailPage.tsx ---
import React, { useState, useMemo } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Button } from "@/components/ui/button";
import { ArrowLeft, Search, X, Globe, Lock, Key, Hash, Shield, Zap, Check, CheckCircle, AlertTriangle, ShieldAlert, Info } from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
 
interface ScanResult {
  request_id: string;
  url: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  requested_at: string;
  total_urls: number;
  execution_time_seconds?: number;
  scan_status?: string;
  tls_version?: string;
  public_key_size_bits?: number;
  cipher_suite_name?: string;
  cipher_protocol?: string;
  cipher_strength_bits?: number;
  ephemeral_key_exchange?: boolean;
  cert_subject?: string;
  cert_issuer?: string;
  cert_serial_number?: string;
  cert_not_before?: string;
  cert_not_after?: string;
  public_key_algorithm?: string;
  hsts_enabled?: boolean;
  csp_enabled?: boolean;
  x_frame_options_enabled?: boolean;
  ocsp_stapling_active?: boolean;
  ct_present?: boolean;
  error_message?: string;
  raw_response?: any;
  quantum_score?: number;
  quantum_grade?: string;
  detailedResults?: ScanResult[];
  finalDomainProgress?: {[key: string]: {status: string, duration?: number}};
  pqc_analysis?: {
    overall_score: number;
    overall_grade: string;
    security_level: string;
    quantum_ready: boolean;
    hybrid_ready: boolean;
    components: {
      kex: ComponentScore;
      signature: ComponentScore;
      symmetric: ComponentScore;
      certificate: ComponentScore;
      protocol: ComponentScore;
    };
  };
}

interface ComponentScore {
  weighted_average: number;
  grade: string;
  pqc_percentage: number;
  quantum_safe_count: number;
}

interface ResultsDetailPageProps {
  scan: ScanResult;
  onBack: () => void;
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

const getGradeColor = (grade: string): string => {
  if (!grade) return 'text-muted-foreground';
  if (grade.startsWith('A')) return 'bg-gradient-to-r from-emerald-500 to-green-500 bg-clip-text text-transparent';
  if (grade.startsWith('B')) return 'bg-gradient-to-r from-blue-500 to-cyan-500 bg-clip-text text-transparent';
  if (grade.startsWith('C')) return 'bg-gradient-to-r from-yellow-400 to-amber-500 bg-clip-text text-transparent';
  if (grade.startsWith('D')) return 'bg-gradient-to-r from-orange-500 to-red-500 bg-clip-text text-transparent';
  return 'bg-gradient-to-r from-rose-500 to-red-500 bg-clip-text text-transparent';
};

const getSectionIcon = (section: string) => {
  const icons: Record<string, React.ReactNode> = {
    "Symmetric Algorithms": <Lock className="w-5 h-5" />,
    "Asymmetric Algorithms": <Key className="w-5 h-5" />,
    "Hash Functions": <Hash className="w-5 h-5" />,
    "MACs & KDFs": <Shield className="w-5 h-5" />,
    "Post-Quantum Cryptography": <Zap className="w-5 h-5" />,
    "kex": <Key className="w-5 h-5" />,
    "signature": <Shield className="w-5 h-5" />,
    "symmetric": <Lock className="w-5 h-5" />,
    "certificate": <Shield className="w-5 h-5" />,
    "protocol": <Globe className="w-5 h-5" />
  };
  return icons[section] || <Shield className="w-5 h-5" />;
};

const PQCStatusBadges: React.FC<{
  is_pqc?: boolean;
  is_hybrid?: boolean;
  quantum_safe?: boolean;
}> = ({ is_pqc, is_hybrid, quantum_safe }) => (
  <div className="flex items-center gap-2 flex-wrap">
    {is_pqc && <span className="px-1.5 py-0.5 text-xs bg-purple-100 dark:bg-purple-900/30 rounded text-purple-700 dark:text-purple-300">PQC</span>}
    {is_hybrid && <span className="px-1.5 py-0.5 text-xs bg-blue-100 dark:bg-blue-900/30 rounded text-blue-700 dark:text-blue-300">Hybrid</span>}
    {quantum_safe && <span className="px-1.5 py-0.5 text-xs bg-green-100 dark:bg-green-900/30 rounded text-green-700 dark:text-green-300">Quantum-Safe</span>}
  </div>
);


// ============================================================================
// DETAIL COMPONENTS
// ============================================================================

const DetailSection: React.FC<{ title: string; children: React.ReactNode }> = ({ title, children }) => {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    <div className="border border-white/20 rounded-xl mb-4 backdrop-blur-xl bg-white/80 dark:bg-slate-900/80">
      <div 
        className="flex items-center justify-between p-3 bg-muted hover:bg-muted/80 cursor-pointer transition-colors"
        onClick={(e) => {
          e.stopPropagation();
          setIsOpen(!isOpen);
        }}
      >
        <h4 className="font-medium">{title}</h4>
        <motion.div
          animate={{ rotate: isOpen ? 180 : 0 }}
          transition={{ duration: 0.2 }}
        >
          <ArrowLeft className="h-4 w-4" />
        </motion.div>
      </div>
      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.2 }}
            className="overflow-hidden"
          >
            <div className="p-6 space-y-2">
              {children}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

const DetailRow: React.FC<{ label: string; value: string | React.ReactNode; className?: string }> = ({ label, value, className = '' }) => (
  <div className={`flex justify-between items-start py-1 ${className}`}>
    <span className="text-slate-500 font-semibold text-xs uppercase tracking-wider min-w-0 flex-shrink">{label}:</span>
    <span className="text-foreground text-right ml-4 min-w-0 break-words">{value}</span>
  </div>
);

const ComponentScoreCard: React.FC<{ name: string; data: ComponentScore }> = ({ name, data }) => {
  return (
    <TooltipProvider>
      <div className="flex items-center justify-between p-3 bg-muted/30 rounded-lg">
        <div className="flex items-center gap-3">
          {getSectionIcon(name)}
          <div>
            <div className="font-medium capitalize">{name}</div>
            <div className="text-xs text-slate-500 font-semibold uppercase tracking-wider">
              {data.pqc_percentage}% PQC â€¢ {data.quantum_safe_count} quantum-safe
            </div>
          </div>
        </div>
        <div className="text-right">
          <div className="flex items-center gap-1 justify-end">
            <div className={`text-lg font-bold ${getGradeColor(data.grade)}`}>
              {data.grade}
            </div>
            <Tooltip>
              <TooltipTrigger>
                <Info className="h-3 w-3 text-muted-foreground cursor-help" />
              </TooltipTrigger>
              <TooltipContent>
                <p>This score reflects both classical strength and PQC readiness.</p>
              </TooltipContent>
            </Tooltip>
          </div>
          <div className="text-sm text-muted-foreground">
            Weighted Score: {data.weighted_average.toFixed(1)}/100
          </div>
        </div>
      </div>
    </TooltipProvider>
  );
};

const PQCAnalysisSection: React.FC<{ analysis: any }> = ({ analysis }) => {
  if (!analysis) return null;

  return (
    <DetailSection title="Post-Quantum Cryptography Analysis">
      <div className="p-6 bg-muted/50 rounded-xl mb-4">
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <div>
            <span className="text-xs uppercase tracking-wider font-semibold text-slate-500">Overall Score</span>
            <div className="text-2xl font-bold">{analysis.overall_score.toFixed(2)}/100</div>
          </div>
          <div>
            <span className="text-xs uppercase tracking-wider font-semibold text-slate-500">Grade</span>
            <div className={`text-2xl font-bold ${getGradeColor(analysis.overall_grade)}`}>
              {analysis.overall_grade}
            </div>
          </div>
          <div>
            <span className="text-xs uppercase tracking-wider font-semibold text-slate-500">Security Level</span>
            <div className="text-lg font-semibold capitalize">{analysis.security_level}</div>
          </div>
          <div>
            <span className="text-xs uppercase tracking-wider font-semibold text-slate-500">Quantum Ready</span>
            <div className="text-lg flex items-center gap-2">
              {analysis.quantum_ready 
                ? <><div className="w-5 h-5 rounded-full bg-emerald-500/20 flex items-center justify-center"><Check className="w-3 h-3 text-emerald-600" /></div><span>Yes</span></>
                : <><div className="w-5 h-5 rounded-full bg-rose-500/20 flex items-center justify-center"><X className="w-3 h-3 text-rose-600" /></div><span>No</span></>}
            </div>
          </div>
        </div>
      </div>

      <div className="space-y-3">
        <h5 className="font-semibold text-sm">Component Analysis</h5>
        {Object.entries(analysis.components).map(([key, value]: [string, any]) => (
          <ComponentScoreCard key={key} name={key} data={value} />
        ))}
      </div>
    </DetailSection>
  );
};

const DetailedSections: React.FC<{ result: any }> = ({ result }) => {
  const rawData = result.raw_response || {};
  const tlsConfig = rawData.tls_configuration || {};
  const certChain = rawData.certificate_chain || {};
  const leafCert = certChain.leaf_certificate || {};
  const signatureAlgorithms = rawData.signature_algorithms || {};
  
  const getHashFromCipherName = (name: string): string => {
    const hashMatch = name.match(/SHA\d+/);
    if (hashMatch) return hashMatch[0];
    if (name.endsWith('_SHA')) return 'SHA1';
    return 'N/A';
  };

  return (
    <div className="space-y-3 max-h-[70vh] overflow-y-auto pr-4">
      <DetailSection title="TLS/SSL Information">
        <DetailRow label="Supported Protocols" value={(tlsConfig.supported_protocols || []).join(', ') || 'N/A'} />
      </DetailSection>

      <DetailSection title="Elliptic Curves">
        {(tlsConfig.supported_elliptic_curves?.curves || []).map((curve: any, idx: number) => (
          <div key={idx} className="p-4 bg-muted/50 rounded-xl mb-2">
            <div className="flex justify-between items-start">
              <div className="font-medium">{curve.name}</div>
              <div className="text-sm text-muted-foreground">{curve.type} ({curve.bits} bits)</div>
            </div>
            {curve.curve_pqc_score !== undefined && (
              <div className="mt-2 flex items-center justify-between">
                <PQCStatusBadges 
                  is_pqc={curve.curve_is_pqc}
                  is_hybrid={curve.curve_is_hybrid}
                  quantum_safe={curve.curve_quantum_safe}
                />
                <div className={`text-sm font-semibold ${getGradeColor(curve.curve_pqc_grade)}`}>{curve.curve_pqc_grade} ({curve.curve_pqc_score})</div>
              </div>
            )}
          </div>
        ))}
      </DetailSection>

      <DetailSection title="Certificate Chain">
        <div className="mb-4 p-5 bg-muted/50 rounded-xl">
          <div className="font-semibold mb-2">Leaf Certificate</div>
          <DetailRow label="Certificate" value={leafCert.certificate || 'N/A'} />
          <DetailRow label="Subject Alt Names" value={(leafCert.subject_alternative_names || []).join(', ') || 'N/A'} />
          <DetailRow label="Certificate Transparency" value={leafCert.certificate_transparency ? <div className="flex items-center gap-2"><div className="w-5 h-5 rounded-full bg-emerald-500/20 flex items-center justify-center"><Check className="w-3 h-3 text-emerald-600" /></div><span>Yes</span></div> : <div className="flex items-center gap-2"><div className="w-5 h-5 rounded-full bg-rose-500/20 flex items-center justify-center"><X className="w-3 h-3 text-rose-600" /></div><span>No</span></div>} />
          {leafCert.cert_pqc_score !== undefined && (
            <div className="mt-3 pt-3 border-t">
              <DetailRow label="PQC Grade" value={<span className={`font-bold ${getGradeColor(leafCert.cert_pqc_grade)}`}>{leafCert.cert_pqc_grade} ({leafCert.cert_pqc_score})</span>} />
              <DetailRow label="Status" value={<PQCStatusBadges 
                is_pqc={leafCert.cert_is_pqc}
                is_hybrid={leafCert.cert_is_hybrid}
                quantum_safe={leafCert.cert_quantum_safe}
              />} />
            </div>
          )}
        </div>

        {(certChain.intermediate_certificates || []).map((cert: any, index: number) => (
          <div key={`intermediate-${index}`} className="mb-4 p-5 bg-muted/50 rounded-xl">
            <div className="font-semibold mb-2">Intermediate Certificate {index + 1}</div>
            <DetailRow label="Public Key Algorithm" value={cert.public_key_algorithm || 'N/A'} />
            <DetailRow label="Public Key Size" value={`${cert.public_key_size || 'N/A'} bits`} />
            {cert.cert_pqc_score !== undefined && (
              <div className="mt-2 pt-2 border-t">
                <DetailRow label="PQC Grade" value={<span className={`font-bold ${getGradeColor(cert.cert_pqc_grade)}`}>{cert.cert_pqc_grade} ({cert.cert_pqc_score})</span>} />
                <DetailRow label="Status" value={<PQCStatusBadges 
                  is_pqc={cert.cert_is_pqc}
                  is_hybrid={cert.cert_is_hybrid}
                  quantum_safe={cert.cert_quantum_safe}
                />} />
              </div>
            )}
          </div>
        ))}
      </DetailSection>

      {signatureAlgorithms.certificate_signatures && signatureAlgorithms.certificate_signatures.length > 0 && (
        <DetailSection title="Certificate Signatures">
          <div className="space-y-3">
            {signatureAlgorithms.certificate_signatures.map((sig: any, idx: number) => (
              <div key={idx} className="p-5 bg-muted/50 rounded-xl">
                <div className="font-semibold mb-2">Position {sig.position}: {sig.certificate_subject}</div>
                <DetailRow label="Signature Algorithm" value={sig.signature_algorithm} />
                <DetailRow label="Hash Algorithm" value={sig.hash_algorithm} />
                <DetailRow label="Public Key" value={`${sig.public_key_type} (${sig.public_key_size} bits)`} />
                {sig.sig_pqc_score !== undefined && (
                  <div className="mt-2 pt-2 border-t">
                    <div className="text-xs uppercase tracking-wider font-semibold text-slate-500 mb-1">Signature Analysis</div>
                    <DetailRow label="PQC Grade" value={<span className={`font-bold ${getGradeColor(sig.sig_pqc_grade)}`}>{sig.sig_pqc_grade} ({sig.sig_pqc_score})</span>} />
                    <DetailRow label="Status" value={<PQCStatusBadges 
                      is_pqc={sig.sig_is_pqc}
                      is_hybrid={sig.sig_is_hybrid}
                      quantum_safe={sig.sig_quantum_safe}
                    />} />
                  </div>
                )}
                {sig.hash_pqc_score !== undefined && (
                  <div className="mt-2 pt-2 border-t">
                    <div className="text-xs uppercase tracking-wider font-semibold text-slate-500 mb-1">Hash Analysis</div>
                    <DetailRow label="PQC Grade" value={<span className={`font-bold ${getGradeColor(sig.hash_pqc_grade)}`}>{sig.hash_pqc_grade} ({sig.hash_pqc_score})</span>} />
                  </div>
                )}
              </div>
            ))}
          </div>
        </DetailSection>
      )}

      <DetailSection title="Handshake Signature Algorithms">
        {signatureAlgorithms.handshake_signatures && signatureAlgorithms.handshake_signatures.length > 0 ? (
          <div className="space-y-3">
            {signatureAlgorithms.handshake_signatures.map((sig: any, idx: number) => (
              <div key={idx} className="p-4 bg-muted/50 rounded-xl">
                <div className="flex justify-between items-start">
                  <div className="font-medium">{sig.algorithm}</div>
                  <div className="text-sm text-muted-foreground">{sig.protocol}</div>
                </div>
                {sig.sig_pqc_score !== undefined && (
                  <div className="mt-2 flex items-center justify-between">
                    <PQCStatusBadges 
                      is_pqc={sig.sig_is_pqc}
                      is_hybrid={sig.sig_is_hybrid}
                      quantum_safe={sig.sig_quantum_safe}
                    />
                    <div className={`text-sm font-semibold ${getGradeColor(sig.sig_pqc_grade)}`}>{sig.sig_pqc_grade} ({sig.sig_pqc_score})</div>
                  </div>
                )}
              </div>
            ))}
          </div>
        ) : (
          <p className="text-muted-foreground text-sm">No handshake signature algorithms available</p>
        )}
      </DetailSection>

      <DetailSection title="Cipher Suites">
        {tlsConfig['tls_1.3_cipher_suites'] && (
          <div className="mb-6">
            <div className="font-semibold mb-2 flex justify-between items-center">
              <span>TLS 1.3 Cipher Suites</span>
              {tlsConfig['tls_1.3_cipher_suites'].component_kex_score !== undefined && (
                <div className="text-sm">
                  <span className="text-muted-foreground">KEX Score: </span>
                  <span className={`font-bold ${getGradeColor(tlsConfig['tls_1.3_cipher_suites'].component_kex_grade)}`}>
                    {tlsConfig['tls_1.3_cipher_suites'].component_kex_grade} ({tlsConfig['tls_1.3_cipher_suites'].component_kex_score})
                  </span>
                </div>
              )}
            </div>
            {(tlsConfig['tls_1.3_cipher_suites'].suites || []).map((cipher: any, idx: number) => (
              <div key={idx} className="border-b border-border last:border-0 py-3">
                <div className="flex justify-between items-start mb-2">
                  <div className="flex-1">
                    <div className="font-medium">{cipher.name}</div>
                    <div className="text-xs text-muted-foreground mt-1">
                      Encryption: {cipher.encryption} | Hash: {getHashFromCipherName(cipher.name)}
                    </div>
                  </div>
                  <div className="text-sm text-muted-foreground ml-4">
                    {cipher.key_exchange} {cipher.curve_bits ? `(${cipher.curve_bits} bits)` : ''}
                  </div>
                </div>
                
                {cipher.kex_pqc_score !== undefined && (
                  <div className="flex gap-4 text-xs mt-2">
                    <div className="flex items-center gap-2">
                      <span className="text-muted-foreground">KEX:</span>
                      <span className={`font-semibold ${getGradeColor(cipher.kex_pqc_grade)}`}>
                        {cipher.kex_pqc_grade} ({cipher.kex_pqc_score})
                      </span>
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
        {tlsConfig['tls_1.2_cipher_suites'] && (
          <div>
            <div className="font-semibold mb-2 flex justify-between items-center">
              <span>TLS 1.2 Cipher Suites</span>
              {tlsConfig['tls_1.2_cipher_suites'].component_kex_score !== undefined && (
                <div className="text-sm">
                  <span className="text-muted-foreground">KEX Score: </span>
                  <span className={`font-bold ${getGradeColor(tlsConfig['tls_1.2_cipher_suites'].component_kex_grade)}`}>
                    {tlsConfig['tls_1.2_cipher_suites'].component_kex_grade} ({tlsConfig['tls_1.2_cipher_suites'].component_kex_score})
                  </span>
                </div>
              )}
            </div>
            {(tlsConfig['tls_1.2_cipher_suites'].suites || []).map((cipher: any, idx: number) => (
              <div key={idx} className="border-b border-border last:border-0 py-3">
                <div className="flex justify-between items-start mb-2">
                  <div className="flex-1">
                    <div className="font-medium">{cipher.name}</div>
                    <div className="text-xs text-muted-foreground mt-1">
                      Encryption: {cipher.encryption} | Hash: {getHashFromCipherName(cipher.name)}
                    </div>
                  </div>
                  <div className="text-sm text-muted-foreground ml-4">
                    {cipher.key_exchange} {cipher.curve_bits ? `(${cipher.curve_bits} bits)` : ''}
                  </div>
                </div>
                
                {cipher.kex_pqc_score !== undefined && (
                  <div className="flex gap-4 text-xs mt-2">
                    <div className="flex items-center gap-2">
                      <span className="text-muted-foreground">KEX:</span>
                      <span className={`font-semibold ${getGradeColor(cipher.kex_pqc_grade)}`}>
                        {cipher.kex_pqc_grade} ({cipher.kex_pqc_score})
                      </span>
                      <PQCStatusBadges 
                        is_pqc={cipher.kex_is_pqc}
                        is_hybrid={cipher.kex_is_hybrid}
                        quantum_safe={cipher.kex_quantum_safe}
                      />
                    </div>
                    <div className="flex items-center gap-2">
                      <span className="text-muted-foreground">Encryption:</span>
                      <span className={`font-semibold ${getGradeColor(cipher.encryption_pqc_grade)}`}>
                        {cipher.encryption_pqc_grade} ({cipher.encryption_pqc_score})
                      </span>
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </DetailSection>

      {rawData.pqc_analysis && (
        <PQCAnalysisSection analysis={rawData.pqc_analysis} />
      )}

      {rawData && Object.keys(rawData).length > 0 && (
        <DetailSection title="Raw Scan Data (JSON)">
          <div className="bg-muted p-6 rounded-xl overflow-auto max-h-80">
            <pre className="text-xs font-mono whitespace-pre-wrap break-words">
              {JSON.stringify(rawData, null, 2)}
            </pre>
          </div>
        </DetailSection>
      )}
    </div>
  );
};

// ============================================================================
// MODAL COMPONENT
// ============================================================================

const ExpandedDetailModal: React.FC<{
  result: ScanResult;
  onClose: () => void;
}> = ({ result, onClose }) => {
  const isSuccess = result.scan_status === 'success';
  const pqcScore = result.raw_response?.pqc_analysis?.overall_score ?? result.quantum_score ?? 'N/A';
  const pqcGrade = result.raw_response?.pqc_analysis?.overall_grade ?? result.quantum_grade ?? 'N/A';

  return (
    <>
      {/* Backdrop */}
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        transition={{ duration: 0.2 }}
        onClick={onClose}
        className="fixed inset-0 bg-black/60 backdrop-blur-md z-40"
      />

      {/* Modal */}
      <motion.div
        initial={{ opacity: 0, scale: 0.95, y: 20 }}
        animate={{ opacity: 1, scale: 1, y: 0 }}
        exit={{ opacity: 0, scale: 0.95, y: 20 }}
        transition={{ duration: 0.3, ease: "easeOut" }}
        className="fixed inset-4 md:inset-8 lg:inset-16 z-50 flex flex-col"
        onClick={(e) => e.stopPropagation()}
      >
        <Card className="flex flex-col h-full shadow-2xl border border-white/20 ring-1 ring-black/5 backdrop-blur-xl bg-white/80 dark:bg-slate-900/80">
          {/* Modal Header */}
          <div className="flex items-center justify-between p-6 border-b">
            <div className="flex-1">
              <h3 className="text-xl font-bold truncate">{result.url}</h3>
              <div className="text-sm text-muted-foreground mt-1">
                {isSuccess 
                  ? <div className="flex items-center gap-2"><div className="w-5 h-5 rounded-full bg-emerald-500/20 flex items-center justify-center"><Check className="w-3 h-3 text-emerald-600" /></div><span>Scan Successful</span></div>
                  : <div className="flex items-center gap-2"><div className="w-5 h-5 rounded-full bg-rose-500/20 flex items-center justify-center"><X className="w-3 h-3 text-rose-600" /></div><span>Scan Failed</span></div>}
              </div>
            </div>
            <Button
              variant="ghost"
              size="icon"
              onClick={onClose}
              className="ml-4 flex-shrink-0"
            >
              <X className="h-5 w-5" />
            </Button>
          </div>

          {/* Modal Content */}
          <CardContent className="flex-1 overflow-y-auto p-6">
            {isSuccess ? (
              <div className="space-y-8">
                {/* Quick Stats */}
                <div className="grid grid-cols-3 gap-4 pb-6 border-b">
                  <div className="text-center">
                    <div className="text-xs uppercase tracking-wider font-semibold text-slate-500">PQC Score</div>
                    <div className="text-3xl font-bold mt-2">{pqcScore}</div>
                  </div>
                  <div className="text-center">
                    <div className="text-xs uppercase tracking-wider font-semibold text-slate-500">Grade</div>
                    <div className={`text-3xl font-bold mt-2 ${getGradeColor(pqcGrade)}`}>
                      {pqcGrade}
                    </div>
                  </div>
                  <div className="text-center">
                    <div className="text-xs uppercase tracking-wider font-semibold text-slate-500">Status</div>
                    <div className="text-2xl font-bold mt-2 flex items-center justify-center"><div className="w-5 h-5 rounded-full bg-emerald-500/20 flex items-center justify-center"><Check className="w-3 h-3 text-emerald-600" /></div></div>
                  </div>
                </div>

                {/* Detailed Sections */}
                <DetailedSections result={result} />
              </div>
            ) : (
              <div className="p-6 bg-destructive/10 text-destructive rounded-xl">
                <p className="font-semibold text-lg mb-2">Scan Failed</p>
                <p>{result.error_message || 'An unknown error occurred.'}</p>
              </div>
            )}
          </CardContent>

          {/* Modal Footer */}
          <div className="border-t p-6 flex justify-between items-center">
            <p className="text-xs text-muted-foreground">
              Click outside or press the close button to dismiss
            </p>
            <motion.div whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.95 }}>
              <Button variant="outline" onClick={onClose}>
                <X className="h-4 w-4 mr-2" /> Close
              </Button>
            </motion.div>
          </div>
        </Card>
      </motion.div>
    </>
  );
};

// ============================================================================
// DOMAIN CARD COMPONENT
// ============================================================================

const DomainCard: React.FC<{
  result: ScanResult;
  onExpand: () => void;
}> = ({ result, onExpand }) => {
  const isSuccess = result.scan_status === 'success';
  const pqcScore = result.raw_response?.pqc_analysis?.overall_score ?? result.quantum_score ?? 'N/A';
  const pqcGrade = result.raw_response?.pqc_analysis?.overall_grade ?? result.quantum_grade ?? 'N/A';

  return (
    <Card 
      className={`cursor-pointer transition-all duration-300 ease-out hover:scale-[1.02] hover:shadow-2xl hover:-translate-y-1 border-l-4 ${
        isSuccess ? 'border-l-emerald-500' : 'border-l-rose-500'
      }`}
      onClick={onExpand}
    >
      <CardContent className="p-6">
        <div className="space-y-3">
          <div className="flex items-start justify-between gap-2">
            <div className="flex-1 min-w-0">
              <h5 className="font-semibold truncate text-base">{result.url}</h5>
              <div className="text-xs text-muted-foreground mt-1">
                {isSuccess 
                  ? <div className="flex items-center gap-2"><div className="w-5 h-5 rounded-full bg-emerald-500/20 flex items-center justify-center"><Check className="w-3 h-3 text-emerald-600" /></div><span>Successful</span></div>
                  : <div className="flex items-center gap-2"><div className="w-5 h-5 rounded-full bg-rose-500/20 flex items-center justify-center"><X className="w-3 h-3 text-rose-600" /></div><span>Failed</span></div>}
              </div>
            </div>
            <div className={`w-3 h-3 rounded-full flex-shrink-0 mt-1 animate-pulse ${
              isSuccess ? 'bg-emerald-500 shadow-lg shadow-emerald-500/50' : 'bg-rose-500 shadow-lg shadow-rose-500/50'
            }`}></div>
          </div>

          {isSuccess && (
            <div className="grid grid-cols-3 gap-2 text-center">
              <div className="bg-muted p-2 rounded-xl">
                <div className="text-xs uppercase tracking-wider font-semibold text-slate-500">PQC Score</div>
                <div className="font-bold text-sm">{pqcScore}</div>
              </div>
              <div className="bg-muted p-2 rounded-xl">
                <div className="text-xs uppercase tracking-wider font-semibold text-slate-500">Grade</div>
                <div className={`font-bold text-sm ${getGradeColor(pqcGrade)}`}>
                  {pqcGrade}
                </div>
              </div>
              <div className="bg-muted p-2 rounded-xl">
                <div className="text-xs uppercase tracking-wider font-semibold text-slate-500">Status</div>
                <div className="font-bold text-sm">Success</div>
              </div>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
};

// ============================================================================
// MAIN RESULTS DETAIL PAGE COMPONENT
// ============================================================================

const ResultsDetailPage: React.FC<ResultsDetailPageProps> = ({ scan, onBack }) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [expandedResult, setExpandedResult] = useState<ScanResult | null>(null);

  // Filter results based on search query
  const filteredResults = useMemo(() => {
    if (!scan.detailedResults) return [];
    return scan.detailedResults.filter(result =>
      result.url.toLowerCase().includes(searchQuery.toLowerCase())
    );
  }, [scan.detailedResults, searchQuery]);

  // Calculate summary stats
  const stats = useMemo(() => {
    if (!scan.detailedResults) return { successful: 0, failed: 0 };
    return {
      successful: scan.detailedResults.filter(r => r.scan_status === 'success').length,
      failed: scan.detailedResults.filter(r => r.scan_status !== 'success').length,
    };
  }, [scan.detailedResults]);

  const cardVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -20 },
  };

  return (
    <motion.div
      variants={cardVariants}
      initial="hidden"
      animate="visible"
      exit="exit"
      transition={{ duration: 0.3 }}
      className="p-4 sm:p-6 max-w-7xl mx-auto"
    >
      {/* Header */}
      <div className="mb-8">
        <motion.div whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.95 }}>
          <Button 
            variant="outline" 
            onClick={onBack} 
            className="mb-4"
          >
            <ArrowLeft className="h-4 w-4 mr-2" /> Back to Scan History
          </Button>
        </motion.div>
        
        <div>
          <h2 className="text-3xl sm:text-4xl font-bold bg-gradient-to-r from-slate-900 to-slate-700 dark:from-white dark:to-slate-300 bg-clip-text text-transparent">
            Scan Results
          </h2>
          <p className="text-sm text-muted-foreground mt-1">
            Request ID: {scan.request_id}
          </p>
        </div>

        {/* Stats Row */}
        <div className="grid grid-cols-3 gap-4 mt-6">
          <Card className="relative overflow-hidden backdrop-blur-xl bg-white/80 dark:bg-slate-900/80 border border-white/20 rounded-xl shadow-md hover:shadow-xl transition-all duration-300">
            <div className="absolute -right-4 -top-4 w-24 h-24 bg-gradient-to-br from-emerald-500/10 to-green-500/10 rounded-full blur-2xl"></div>
            <CardContent className="p-5 text-center relative z-10">
              <div className="w-12 h-12 mx-auto mb-3 rounded-xl bg-gradient-to-br from-emerald-500 to-green-600 flex items-center justify-center">
                <CheckCircle className="w-6 h-6 text-white" />
              </div>
              <div className="text-3xl font-bold bg-gradient-to-r from-emerald-600 to-green-600 bg-clip-text text-transparent">
                {stats.successful}
              </div>
              <div className="text-xs uppercase tracking-wider text-slate-500 font-semibold mt-1">
                Successful
              </div>
            </CardContent>
          </Card>
          <Card className="relative overflow-hidden backdrop-blur-xl bg-white/80 dark:bg-slate-900/80 border border-white/20 rounded-xl shadow-md hover:shadow-xl transition-all duration-300">
            <div className="absolute -right-4 -top-4 w-24 h-24 bg-gradient-to-br from-rose-500/10 to-red-500/10 rounded-full blur-2xl"></div>
            <CardContent className="p-5 text-center relative z-10">
              <div className="w-12 h-12 mx-auto mb-3 rounded-xl bg-gradient-to-br from-rose-500 to-red-600 flex items-center justify-center">
                <ShieldAlert className="w-6 h-6 text-white" />
              </div>
              <div className="text-3xl font-bold bg-gradient-to-r from-rose-600 to-red-600 bg-clip-text text-transparent">
                {stats.failed}
              </div>
              <div className="text-xs uppercase tracking-wider text-slate-500 font-semibold mt-1">
                Failed
              </div>
            </CardContent>
          </Card>
          <Card className="relative overflow-hidden backdrop-blur-xl bg-white/80 dark:bg-slate-900/80 border border-white/20 rounded-xl shadow-md hover:shadow-xl transition-all duration-300">
             <div className="absolute -right-4 -top-4 w-24 h-24 bg-gradient-to-br from-slate-500/10 to-slate-500/10 rounded-full blur-2xl"></div>
            <CardContent className="p-5 text-center relative z-10">
               <div className="w-12 h-12 mx-auto mb-3 rounded-xl bg-gradient-to-br from-slate-500 to-slate-600 flex items-center justify-center">
                <Globe className="w-6 h-6 text-white" />
              </div>
              <div className="text-3xl font-bold text-foreground">{scan.detailedResults?.length ?? 0}</div>
              <div className="text-xs uppercase tracking-wider text-slate-500 font-semibold mt-1">Total</div>
            </CardContent>
          </Card>
        </div>
      </div>

      {/* Search Bar */}
      <div className="mb-8 relative">
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
        <Input
          placeholder="Search by domain name..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="pl-10 h-12 border-slate-200 dark:border-slate-700 focus:ring-2 focus:ring-blue-500/20 transition-all"
        />
        <p className="text-xs text-muted-foreground mt-2">
          Showing {filteredResults.length} of {scan.detailedResults?.length ?? 0} domains
        </p>
      </div>

      {/* Domain Cards Grid */}
      {filteredResults.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredResults.map((result, index) => (
            <motion.div
              key={result.url}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: index * 0.05, duration: 0.4 }}
            >
              <DomainCard
                result={result}
                onExpand={() => setExpandedResult(result)}
              />
            </motion.div>
          ))}
        </div>
      ) : (
        <Card className="backdrop-blur-xl bg-white/50 dark:bg-slate-900/50">
          <CardContent className="flex flex-col items-center justify-center py-16">
            <div className="w-16 h-16 rounded-full bg-slate-100 dark:bg-slate-800 flex items-center justify-center mb-4">
              <Search className="w-8 h-8 text-slate-400" />
            </div>
            <p className="text-lg font-semibold text-slate-700 dark:text-slate-300 mb-2">
              {searchQuery ? 'No domains found' : 'No results available'}
            </p>
            <p className="text-sm text-slate-500">
              {searchQuery ? 'Try adjusting your search' : 'Start by running a scan'}
            </p>
          </CardContent>
        </Card>
      )}

      {/* Expanded Modal */}
      <AnimatePresence>
        {expandedResult && (
          <ExpandedDetailModal
            result={expandedResult}
            onClose={() => setExpandedResult(null)}
          />
        )}
      </AnimatePresence>
    </motion.div>
  );
};

export default ResultsDetailPage;

--- File: C:\Users\ASUS\Videos\xencrypt\Frontend\src\components\scan\webscan.tsx ---
import React, { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Button } from "@/components/ui/button";
import { ArrowLeft, ArrowRight, Globe, RefreshCw, Play, Edit, Save, RotateCcw, Plus, Check, X, Shield, Lock, Hash, Key, Zap, Trash2 } from "lucide-react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogClose,
} from "@/components/ui/dialog";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import ResultsDetailPage from './ResultsDetailPage'; // NEW IMPORT

// ============================================================================
// INTERFACES & TYPES
// ============================================================================

interface WebScanProps {
  onBack: () => void;
  apiBaseUrl: string;
}

interface ScanResult {
  request_id: string;
  id?: number; // ADD THIS for individual result deletion
  batch_id?: string; // ADD THIS
  url: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  requested_at: string;
  total_urls: number;
  execution_time_seconds?: number;
  scan_status?: string;
  tls_version?: string;
  public_key_size_bits?: number;
  cipher_suite_name?: string;
  cipher_protocol?: string;
  cipher_strength_bits?: number;
  ephemeral_key_exchange?: boolean;
  cert_subject?: string;
  cert_issuer?: string;
  cert_serial_number?: string;
  cert_not_before?: string;
  cert_not_after?: string;
  public_key_algorithm?: string;
  hsts_enabled?: boolean;
  csp_enabled?: boolean;
  x_frame_options_enabled?: boolean;
  ocsp_stapling_active?: boolean;
  ct_present?: boolean;
  error_message?: string;
  raw_response?: any;
  quantum_score?: number;
  quantum_grade?: string;
  detailedResults?: ScanResult[];
  finalDomainProgress?: {[key: string]: {status: string, duration?: number}};
  pqc_analysis?: {
    overall_score: number;
    overall_grade: string;
    security_level: string;
    quantum_ready: boolean;
    hybrid_ready: boolean;
    components: {
      kex: ComponentScore;
      signature: ComponentScore;
      symmetric: ComponentScore;
      certificate: ComponentScore;
      protocol: ComponentScore;
    };
  };
}

interface ComponentScore {
  weighted_average: number;
  grade: string;
  pqc_percentage: number;
  quantum_safe_count: number;
}

interface DomainProgressInfo {
  status: string;
  duration?: number;
  error?: string;
  round?: number;
  startedAt?: string;
  timeInCurrentRound?: number;
}
interface RoundInfo {
  round: number;
  duration: number;
  domainsProcessed: number;
}

interface ProgressDisplayProps {
  scanProgress: { total: number; completed: number };
  domainProgress: {[key: string]: DomainProgressInfo};
  processingDomains: {[key: string]: DomainProgressInfo};
  currentRound?: number;
  roundHistory: RoundInfo[];
  onCancel?: () => void;
  isCancelling?: boolean;
  isActiveProgress?: boolean;
}

// ============================================================================
// HELPER COMPONENTS
// ============================================================================

const getSectionIcon = (section: string) => {
  const icons: Record<string, React.ReactNode> = {
    "Symmetric Algorithms": <Lock className="w-5 h-5" />,
    "Asymmetric Algorithms": <Key className="w-5 h-5" />,
    "Hash Functions": <Hash className="w-5 h-5" />,
    "MACs & KDFs": <Shield className="w-5 h-5" />,
    "Post-Quantum Cryptography": <Zap className="w-5 h-5" />,
    "kex": <Key className="w-5 h-5" />,
    "signature": <Shield className="w-5 h-5" />,
    "symmetric": <Lock className="w-5 h-5" />,
    "certificate": <Shield className="w-5 h-5" />,
    "protocol": <Globe className="w-5 h-5" />
  };
  return icons[section] || <Shield className="w-5 h-5" />;
};

const getStatusBadge = (status: string) => {
  const colors: Record<string, string> = {
    "Strong": "bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300",
    "Medium": "bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300",
    "Weak": "bg-red-100 text-red-800 dark:bg-red-900/50 dark:text-red-300",
    "Safe": "bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300",
    "Standardized": "bg-purple-100 text-purple-800 dark:bg-purple-900/50 dark:text-purple-300"
  };
  return colors[status] || "bg-muted text-muted-foreground";
};

const getGradeColor = (grade: string): string => {
  if (!grade) return 'text-muted-foreground';
  if (grade.startsWith('A')) return 'text-green-500';
  if (grade.startsWith('B')) return 'text-blue-500';
  if (grade.startsWith('C')) return 'text-yellow-500';
  if (grade.startsWith('D')) return 'text-orange-500';
  return 'text-red-500';
};

const ProgressDisplay: React.FC<ProgressDisplayProps> = ({ 
  scanProgress, 
  domainProgress, 
  processingDomains, 
  currentRound, 
  roundHistory, 
  onCancel, 
  isCancelling,
  isActiveProgress = false
}) => {
  if (Object.keys(domainProgress).length === 0) return null;
  
  const percentage = (scanProgress.completed / scanProgress.total) * 100;
  
  return (
    <Card className={`mb-6 ${isActiveProgress ? 'animate-pulse' : ''}`}>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div className="flex-1">
            <CardTitle>
              {isActiveProgress
                ? `Scan Progress... (Round ${currentRound || 1})`
                : 'Scan Summary'}
            </CardTitle>
            {scanProgress.total > 0 && (
              <CardDescription>
                {scanProgress.completed}/{scanProgress.total} domains scanned ({percentage.toFixed(0)}%)
              </CardDescription>
            )}
          </div>
          {isActiveProgress && onCancel && (
            <Button 
              variant="destructive" 
              size="sm"
              onClick={onCancel}
              disabled={isCancelling}
            >
              {isCancelling ? (
                <>
                  <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                  Cancelling...
                </>
              ) : (
                <>
                  <X className="h-4 w-4 mr-2" />
                  Cancel Scan
                </>
              )}
            </Button>
          )}
        </div>
      </CardHeader>
      <CardContent>
        {scanProgress.total > 0 && (
          <div className="w-full bg-muted rounded-full h-2.5 overflow-hidden mb-4">
            <motion.div
              className="bg-primary h-full rounded-full"
              initial={{ width: 0 }}
              animate={{ width: `${percentage}%` }}
              transition={{ duration: 0.5, ease: "easeInOut" }}
            />
          </div>
        )}
        
        {roundHistory.length > 0 && (
          <div className="mt-4 border-t pt-4">
            <h4 className="font-semibold text-sm mb-2">Round Summary</h4>
            <div className="flex flex-wrap gap-2">
              {roundHistory.map(round => (
                <div key={round.round} className="text-xs bg-muted px-2 py-1 rounded-md">
                  <strong>Round {round.round}:</strong> {round.domainsProcessed} domains in {round.duration.toFixed(1)}s
                </div>
              ))}
            </div>
          </div>
        )}

        {(Object.keys(domainProgress).length > 0 || Object.keys(processingDomains).length > 0) && (
          <div className="mt-4 border-t pt-4">
            <h4 className="font-semibold text-sm mb-2">Domain Status</h4>
          </div>
        )}
        {(Object.keys(domainProgress).length > 0 || Object.keys(processingDomains).length > 0) && (
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 max-h-60 overflow-y-auto">
            <div>
              <h4 className="font-semibold text-sm mb-2 flex items-center gap-2">
                <Check className="h-4 w-4 text-green-500" />
                Successful ({Object.values(domainProgress).filter(i => i.status === 'completed').length})
              </h4>
              <div className="space-y-1">
                {Object.entries(domainProgress)
                  .filter(([, info]) => info.status === 'completed')
                  .map(([domain, info]) => (
                    <div key={domain} className="flex items-center justify-between text-sm py-1 px-2 bg-green-100/50 dark:bg-green-900/20 rounded">
                      <div className="flex items-center gap-2 flex-1 min-w-0">
                        <span className="truncate" title={domain}>{domain}</span>
                      </div>
                      <div className="flex items-center gap-2 flex-shrink-0 ml-2">
                        {info.round && <span className="text-xs text-muted-foreground">R{info.round}</span>}
                        {typeof info.duration === 'number' ? ( // Check if it's explicitly a number
                          <span className="text-muted-foreground text-xs">{info.duration.toFixed(1)}s</span>
                        ) : (
                          <span className="text-muted-foreground text-xs">-</span>
                        )}
                      </div>
                    </div>
                  ))}
              </div>
            </div>
            {isActiveProgress && (
              <div>
                <h4 className="font-semibold text-sm mb-2 flex items-center gap-2">
                  <RefreshCw className="h-4 w-4 text-blue-500 animate-spin" />
                  In Progress ({Object.keys(processingDomains).length})
                </h4>
                <div className="space-y-1">
                  {Object.entries(processingDomains).map(([domain, info]) => (
                    <div key={domain} className={`flex flex-col text-sm py-1 px-2 bg-blue-100/50 dark:bg-blue-900/20 rounded ${ 
                      (info.timeInCurrentRound ?? 0) > 120 ? 'border-l-4 border-l-yellow-500' : ''
                    }`}>
                      <div className="flex items-center justify-between gap-2">
                        <div className="flex items-center gap-2 flex-1 min-w-0">
                          <span className="truncate" title={domain}>{domain}</span>
                        </div>
                        <div className="flex items-center gap-2 flex-shrink-0">
                          {info.round && <span className="text-xs text-muted-foreground">R{info.round}</span>}
                          {info.timeInCurrentRound !== undefined && <span className="text-muted-foreground text-xs animate-pulse">{info.timeInCurrentRound.toFixed(1)}s</span>}
                        </div>
                      </div>
                      {(info.timeInCurrentRound ?? 0) > 120 && (
                        <span className="text-xs text-yellow-600 mt-1">âš ï¸ Taking longer than expected</span>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}
            <div>
              <h4 className="font-semibold text-sm mb-2 flex items-center gap-2">
                <X className="h-4 w-4 text-red-500" />
                Failed ({Object.values(domainProgress).filter(i => i.status === 'failed').length})
              </h4>
              <div className="space-y-2">
                {Object.entries(domainProgress)
                  .filter(([, info]) => info.status === 'failed')
                  .map(([domain, info]) => (
                    <div key={domain} className="p-2 bg-red-100/50 dark:bg-red-900/20 rounded">
                      <div className="flex items-center justify-between text-sm mb-1 gap-2">
                        <div className="flex items-center gap-2 flex-1 min-w-0">                          
                          <span className="truncate font-medium" title={domain}>{domain}</span>
                        </div>
                        <div className="flex items-center gap-2 flex-shrink-0">
                          <span className="text-xs bg-red-200 dark:bg-red-800 px-2 py-1 rounded-full">
                            Failed in Round {info.round}
                          </span>
                          {info.duration && (
                            <span className="text-muted-foreground text-xs">after {info.duration.toFixed(1)}s</span>
                          )}
                        </div>
                      </div>
                      {(info as any).error && (
                        <div className="text-xs text-red-600 dark:text-red-400 mt-1">
                          {(info as any).error}
                        </div>
                      )}
                    </div>
                  ))}
              </div>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

const deleteScanBatch = async (apiBaseUrl: string, batchId: string): Promise<boolean> => {
  try {
    const normalizedBaseUrl = apiBaseUrl.replace(/\/$/, '');
    
    // FIXED: Use correct endpoint path
    const deleteUrl = `${normalizedBaseUrl}/scans/batch/${batchId}`;
    console.log('ðŸ—‘ï¸ Attempting to delete batch at:', deleteUrl);
    
    const response = await fetch(deleteUrl, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    console.log('Response status:', response.status);
    console.log('Response OK:', response.ok);
    
    if (response.ok) {
      const data = await response.json();
      console.log('âœ… Batch deleted successfully:', data);
      return true;
    } else {
      const errorData = await response.text();
      console.error('âŒ Delete failed with status', response.status, ':', errorData);
      return false;
    }
  } catch (error) {
    console.error('âŒ Error deleting batch:', error);
    return false;
  }
};

const deleteScanResult = async (apiBaseUrl: string, resultId: number): Promise<boolean> => {
  try {
    const normalizedBaseUrl = apiBaseUrl.replace(/\/$/, '');
    
    // FIXED: Use correct endpoint path
    const deleteUrl = `${normalizedBaseUrl}/scans/result/${resultId}`;
    console.log('ðŸ—‘ï¸ Attempting to delete result at:', deleteUrl);
    
    const response = await fetch(deleteUrl, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    console.log('Response status:', response.status);
    console.log('Response OK:', response.ok);
    
    if (response.ok) {
      const data = await response.json();
      console.log('âœ… Result deleted successfully:', data);
      return true;
    } else {
      const errorData = await response.text();
      console.error('âŒ Delete failed with status', response.status, ':', errorData);
      return false;
    }
  } catch (error) {
    console.error('âŒ Error deleting result:', error);
    return false;
  }
};

// FIXED: Clear all function with proper error handling
const clearAllScans = async (apiBaseUrl: string): Promise<boolean> => {
  try {
    const normalizedBaseUrl = apiBaseUrl.replace(/\/$/, '');
    
    // FIXED: Use correct endpoint path
    const deleteUrl = `${normalizedBaseUrl}/scans/clear-all`;
    console.log('ðŸ—‘ï¸ Attempting to clear all at:', deleteUrl);
    
    const response = await fetch(deleteUrl, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    console.log('Response status:', response.status);
    console.log('Response OK:', response.ok);
    
    if (response.ok) {
      const data = await response.json();
      console.log('âœ… All data cleared successfully:', data);
      return true;
    } else {
      const errorData = await response.text();
      console.error('âŒ Clear all failed with status', response.status, ':', errorData);
      return false;
    }
  } catch (error) {
    console.error('âŒ Error clearing all scans:', error);
    return false;
  }
};

const loadHistoricalScans = async (apiBaseUrl: string) => {
  try {
    // Call the scan-service which proxies to db-service
    const normalizedBaseUrl = apiBaseUrl.replace(/\/$/, '');
    const response = await fetch(`${normalizedBaseUrl}/batches`);
    
    if (!response.ok) {
      console.warn(`Failed to load historical scans: ${response.status}`);
      return [];
    }
    
    const batchesData = await response.json();
    // Handle both array and object with 'batches' key
    const batches = Array.isArray(batchesData) ? batchesData : (batchesData.batches || []);
    
    // Convert batches to ScanResult format
    return batches.map((batch: any) => ({
      request_id: batch.batch_id, // Use batch_id as the primary key for history items
      batch_id: batch.batch_id,
      url: `Batch with ${batch.total_urls} domains`,
      status: batch.status as 'pending' | 'processing' | 'completed' | 'failed',
      requested_at: batch.created_at,
      total_urls: batch.total_urls,
      // These fields are not in the batch summary, will be loaded on demand
      execution_time_seconds: undefined, 
      scan_status: batch.status === 'completed' ? 'success' : 'failed', // Simplified status
      // Add counts from batch data
      successful_count: batch.successful_count,
      failed_count: batch.failed_count,
      error_message: batch.status === 'failed' ? 'Batch processing failed' : undefined,
      finalDomainProgress: {}, // To be loaded on demand
      detailedResults: [] // Will be loaded on demand
    }));
  } catch (error) {
    console.error('Error loading historical scans from database:', error);
    return [];
  }
};

const loadBatchDetails = async (apiBaseUrl: string, batchId: string) => {
  try {
    // Call the scan-service which proxies to db-service
    const normalizedBaseUrl = apiBaseUrl.replace(/\/$/, '');
    const response = await fetch(`${normalizedBaseUrl}/results/batch/${batchId}`);
    
    if (!response.ok) {
      console.warn(`Failed to load batch details for ${batchId}: ${response.status}`);
      return [];
    }
    
    const data = await response.json();
    const results = Array.isArray(data) ? data : (data.results || []);
    
    // Convert database results to frontend ScanResult format
    return results.map((result: any) => ({
      ...result,
      scan_status: result.status === 'completed' ? 'success' : 'failed',
      total_urls: 1 // Each detailed result is for one URL
    }));
  } catch (error) {
    console.error('Error loading batch details:', error);
    return [];
  }
};



const getStatusIcon = (status: string) => {
  switch (status) {
    case 'completed': return <div className="h-2 w-2 bg-green-500 rounded-full" />;
    case 'failed': return <div className="h-2 w-2 bg-red-500 rounded-full" />;
    case 'processing': return <div className="h-2 w-2 bg-blue-500 rounded-full animate-pulse" />;
    default: return <div className="h-2 w-2 bg-yellow-500 rounded-full" />;
  }
};

const connectSSEWithPost = async (
  apiBaseUrl: string,
  domains: string,
  saveToDb: boolean,  // ADD THIS PARAMETER
  onStart: (requestId: string) => void,
  onProgress: (data: any) => void,
  onComplete: (data: any) => void,
  onError: (error: string) => void
) => {
  try {
    // Normalize API base URL (remove trailing slash)
    const normalizedBaseUrl = apiBaseUrl.replace(/\/$/, '');
    const fullUrl = `${normalizedBaseUrl}/scan-with-progress`;

    console.log('ðŸ” Attempting to connect to:', fullUrl);
    console.log('ðŸ“¦ Request body:', {
      domain: domains,
      max_concurrent: 5,
      save_to_db: saveToDb  // ADD THIS
    });

    const response = await fetch(fullUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'text/event-stream'
      },
      body: JSON.stringify({
        domain: domains,
        max_concurrent: 5,
        save_to_db: saveToDb  // ADD THIS - This is critical!
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const reader = response.body?.getReader();
    const decoder = new TextDecoder();

    if (!reader) {
      throw new Error('No response body');
    }

    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      
      // Process complete SSE messages
      const lines = buffer.split('\n\n');
      buffer = lines.pop() || ''; // Keep incomplete message in buffer

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const data = JSON.parse(line.slice(6));
            
            if (data.type === 'start') {
              onStart(data.request_id);
              onProgress(data);
            } else if (data.type === 'domain_processing') {
              onProgress(data);
            } else if (data.type === 'round_start') { // Restored this handler
              onProgress(data);
            } else if (data.type === 'domain_complete') {
              onProgress(data);
            } else if (data.type === 'round_complete') {
              onProgress(data);
            } else if (data.type === 'retry_wait') {
              // Handle retry_wait separately to show a specific message
              onProgress(data);
            } else if (data.type === 'cancelled') {
              onComplete(data);
              return;
            } else if (data.type === 'complete') {
              onComplete(data);
              return;
            }
          } catch (err) {
            console.error('Parse error:', err);
          }
        }
      }
    }
  } catch (err) {
    console.error('Fetch SSE error:', err);
    onError(err instanceof Error ? err.message : 'Unknown error'); // Pass empty tempRequestId on fetch error
  }
};

// ============================================================================
// MAIN WEBSCAN COMPONENT
// ============================================================================

const WebScan: React.FC<WebScanProps> = ({ onBack, apiBaseUrl }) => {
  const [activeTab, setActiveTab] = useState<'scan' | 'history'>('scan');
  const [urls, setUrls] = useState('');
  const [isScanning, setIsScanning] = useState(false);
  const [scanHistory, setScanHistory] = useState<ScanResult[]>([]);
  const [scanProgress, setScanProgress] = useState({ total: 0, completed: 0 });
  const [expandedSummary, setExpandedSummary] = useState<Set<string>>(new Set());
  const [message, setMessage] = useState<{ text: string; type: 'success' | 'error' | 'info' | 'warning' } | null>(null);
  const [uploadedFile, setUploadedFile] = useState<File | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [domainProgress, setDomainProgress] = useState<{[key: string]: DomainProgressInfo}>({});
  const [processingDomains, setProcessingDomains] = useState<{[key: string]: DomainProgressInfo}>({});
  const [currentRequestId, setCurrentRequestId] = useState<string | null>(null);
  const [isCancelling, setIsCancelling] = useState(false);
  const [currentBatchId, setCurrentBatchId] = useState<string | null>(null); // ADD THIS
  const [expandedProgress, setExpandedProgress] = useState<Set<string>>(new Set());
  const [roundHistory, setRoundHistory] = useState<RoundInfo[]>([]);
  const [currentRound, setCurrentRound] = useState(1);const [viewingResultsFor, setViewingResultsFor] = useState<string | null>(null);

  // Load historical scans on component mount from the API
  useEffect(() => {
    const initializeScans = async () => {
      console.log('Loading scan history from database...');
      const historicalScans = await loadHistoricalScans(apiBaseUrl);
      if (historicalScans && historicalScans.length > 0) {
        console.log(`Loaded ${historicalScans.length} scans from database`);
        setScanHistory(historicalScans);
      } else {
        console.log('No scans found in database');
      }
    };
    
    initializeScans();
  }, [apiBaseUrl]);

  // ============================================================================
  // NO localStorage STORAGE - DATABASE IS THE SOURCE OF TRUTH
  // ============================================================================
  // Removed: useEffect that saves/loads from localStorage
  // The database is now the single source of truth

  const showMessage = (text: string, type: 'success' | 'error' | 'info' | 'warning') => {
    setMessage({ text, type });
    setTimeout(() => setMessage(null), 5000);
  };

  const handleCancelScan = async () => {
    if (!currentRequestId) return;
    
    setIsCancelling(true);
    try {
      const response = await fetch(`${apiBaseUrl}/cancel-scan/${currentRequestId}`, {
        method: 'POST'
      });
      
      if (response.ok) {
        showMessage('Cancelling scan...', 'warning');
      }
    } catch (error) {
      showMessage('Failed to cancel scan', 'error');
    }
  };

  const processFileUrls = async (file: File): Promise<string[]> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        const text = e.target?.result as string;
        // Split by newlines and filter empty lines
        const urls = text
          .split('\n')
          .map(line => line.trim())
          .filter(line => line !== '' && !line.startsWith('#')); // Allow comments with #
        resolve(urls);
      };
      
      reader.onerror = () => reject(new Error('Failed to read file'));
      reader.readAsText(file);
    });
  };

  const handleFileSelect = async (file: File) => {
    // Validate file type
    if (!file.name.endsWith('.txt')) {
      showMessage('Please upload a .txt file only', 'error');
      return;
    }

    // Validate file size (max 1MB)
    if (file.size > 1024 * 1024) {
      showMessage('File size should be less than 1MB', 'error');
      return;
    }

    try {
      const urls = await processFileUrls(file);
      if (urls.length === 0) {
        showMessage('No valid URLs found in the file', 'warning');
        return;
      }

      setUploadedFile(file);
      setUrls(urls.join('\n')); // Add URLs to textarea
      showMessage(`Successfully loaded ${urls.length} URL(s) from file`, 'success');
    } catch (error) {
      showMessage('Error reading file: ' + (error instanceof Error ? error.message : 'Unknown error'), 'error');
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    
    const files = Array.from(e.dataTransfer.files);
    if (files.length > 0) {
      handleFileSelect(files[0]);
    }
  };

  const handleDragOver = (e: React.DragEvent) => { e.preventDefault(); setIsDragging(true); };
  const handleDragLeave = (e: React.DragEvent) => { e.preventDefault(); setIsDragging(false); };
  const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) => { const files = e.target.files; if (files && files.length > 0) { handleFileSelect(files[0]); } };
  const removeFile = () => { setUploadedFile(null); setUrls(''); showMessage('File removed and URLs cleared', 'info'); };

  const generateRequestId = () => {
    return Date.now().toString() + Math.random().toString(36).substr(2, 9);
  };

  const handleScanSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const urlList = urls
      .split(/[\s,\n]+/)
      .map(u => u.trim().replace(/^(https?:\/\/)?(www\.)?/, '').replace(/\/$/, ''))
      .filter(u => u !== '');

    if (urlList.length === 0) {
      showMessage('Please enter at least one URL', 'error');
      return;
    }

    const tempRequestId = generateRequestId(); // This will be used to track the scan before we get a real ID
    const overallStartTime = Date.now();
    
    setIsScanning(true);
    setScanProgress({ total: urlList.length, completed: 0 });
    setDomainProgress({});
    setExpandedSummary(new Set()); // Clear summary on new scan
    setProcessingDomains({});
    setRoundHistory([]);
    setCurrentRequestId(null);
    setIsCancelling(false);
    setCurrentBatchId(null);
    showMessage(`Initiating scan for ${urlList.length} URL(s)...`, 'info');

    const pendingScan: ScanResult = {
      request_id: tempRequestId,
      url: urlList.join(', '),
      status: 'processing',
      requested_at: new Date().toISOString(),
      total_urls: urlList.length,
    };

    setScanHistory(prev => [pendingScan, ...prev]);

    const accumulatedResults: ScanResult[] = [];
    let actualRequestId: string | null = null;

    await connectSSEWithPost(
      apiBaseUrl,
      urlList.join(','),
      true,  // ADD THIS - Enable database persistence
      
      // onStart callback
      (requestId) => {
        actualRequestId = requestId;
        setCurrentRequestId(requestId);
      },
      
      // onProgress callback
      (data) => {
        if (data.type === 'start') {
          const backendRequestId = data.request_id;
          const backendBatchId = data.batch_id;
          setCurrentRequestId(backendRequestId);
          setCurrentBatchId(backendBatchId);
          setScanHistory(prev => prev.map(scan => 
            scan.request_id === tempRequestId
              ? { ...scan, request_id: backendRequestId, batch_id: backendBatchId }
              : scan
          ));
          setScanProgress({ total: data.total_domains, completed: 0 });
          showMessage(`Starting scan of ${data.total_domains} domains...`, 'info');
        } else if (data.type === 'round_start') {
          setCurrentRound(data.round);
          setRoundHistory(prev => [...prev, {
            round: data.round,
            duration: 0,
            domainsProcessed: 0
          }]);
        } else if (data.type === 'domain_processing') {
          setProcessingDomains(prev => ({
            ...prev,
            [data.domain]: {
              status: 'processing',
              round: data.round,
              startedAt: data.started_at, // Use backend's field name
              timeInCurrentRound: 0
            }
          }));
        } else if (data.type === 'domain_complete') {
          // FIRST: Remove from processing
          setProcessingDomains(prev => {
            const newProcessing = {...prev};
            delete newProcessing[data.domain];
            return newProcessing;
          });

          // Update overall progress
          setScanProgress({ 
            total: data.total_domains, 
            completed: data.completed 
          });
          // Update individual domain progress
          setDomainProgress(prev => ({
            ...prev,
            [data.domain]: {
              status: data.status,
              duration: data.duration,
              error: data.error,
              round: data.round,
              timeInCurrentRound: data.time_in_current_round
            }
          }));

          // If scan succeeded, store the result
          if (data.status === 'completed' && data.result) {
            // Backend already formats the result, just add the correct request_id
            accumulatedResults.push({
              ...data.result,
              request_id: actualRequestId || tempRequestId, // Use actual ID
            });
          } else if (data.status === 'failed') {
            // Add a result for the failed domain
            accumulatedResults.push({
              request_id: actualRequestId || tempRequestId,
              url: data.domain,
              status: 'failed',
              scan_status: 'failed',
              error_message: data.error || 'Scan failed for an unknown reason.',
              requested_at: new Date().toISOString(),
              total_urls: 1,
              execution_time_seconds: data.duration,
              raw_response: data.result,
            });
          }

          // Show progress message
        } else if (data.type === 'round_complete') {
          setRoundHistory(prev => prev.map(r => r.round === data.round ? {
            ...r,
            duration: data.duration,
            domainsProcessed: data.domains_processed
          } : r));
        } else if (data.type === 'retry_wait') {
          showMessage(
            `â³ Waiting ${data.delay}s before retry round ${data.next_round}. Retrying ${data.domains_to_retry} failed domains...`,
            'info'
          );
        }
      },
      
      // onComplete callback
      (data) => {
        const endTime = Date.now();
        const executionTimeSeconds = (endTime - overallStartTime) / 1000;

        const finalDomainStatusFromBackend = data.all_domains_status || domainProgress;

        const successfulCount = data.summary?.successful || 0;
        const failedCount = data.summary?.failed || 0;
        const totalScanned = successfulCount + failedCount;
        const hasFailures = failedCount > 0;

        // CRITICAL FIX: Use currentBatchId to find and update the correct scan
        setScanHistory(prev => prev.map(scan => {
          // Match by batch_id if available, otherwise by request_id
          const isMatchingScan = currentBatchId
            ? scan.batch_id === currentBatchId
            : scan.request_id === (actualRequestId || tempRequestId);

          if (isMatchingScan) {
            return {
              ...scan,
              status: (data.type === 'cancelled' || (hasFailures && totalScanned === scan.total_urls)) ? 'failed' : 'completed',
              detailedResults: accumulatedResults,
              finalDomainProgress: finalDomainStatusFromBackend,
              execution_time_seconds: executionTimeSeconds,
              error_message: data.message || (hasFailures ? `${failedCount} domains failed.` : undefined)
            };
          }
          return scan;
        }));

        setDomainProgress(finalDomainStatusFromBackend);

        showMessage(
          data.type === 'cancelled' ? 'Scan cancelled.' : `Scan completed! ${successfulCount} successful, ${failedCount} failed.`,
          hasFailures ? 'warning' : 'success'
        );
        setCurrentRequestId(null);
        setIsCancelling(false);
        setIsScanning(false);
        setScanProgress({ total: 0, completed: 0 });
        setProcessingDomains({}); // Clear processing domains
        setExpandedProgress(new Set()); // Clear expanded progress
      },
      
      // onError callback
      (error) => {
        const endTime = Date.now();
        const executionTimeSeconds = (endTime - overallStartTime) / 1000;

        setDomainProgress(currentProgress => {
          setScanHistory(prev => prev.map(scan => 
            scan.request_id === (actualRequestId || tempRequestId)
              ? { 
                  ...scan,
                  request_id: actualRequestId || tempRequestId,
                  status: 'failed',
                  error_message: error,
                  execution_time_seconds: executionTimeSeconds,
                  detailedResults: accumulatedResults.length > 0 ? accumulatedResults : undefined,
                  finalDomainProgress: { ...currentProgress }
                }
              : scan
          ));
          return currentProgress; // Return unchanged
        });

        showMessage(`âŒ Scan failed: ${error}`, 'error');
        setCurrentRequestId(null);
        setIsCancelling(false);
        setIsScanning(false);
      }
    );
  };

  const toggleSummary = (requestId: string) => {
    // Toggle Summary
    setExpandedSummary(prev => {
      const newSet = new Set(prev);
      if (newSet.has(requestId)) newSet.delete(requestId);
      else newSet.add(requestId);
      return newSet;
    });
  };

  const toggleProgress = (requestId: string) => {
    setExpandedProgress(prev => {
      const newSet = new Set(prev);
      if (newSet.has(requestId)) newSet.delete(requestId);
      else newSet.add(requestId);
      return newSet;
    });
  };

  const handleLoadBatchDetails = async (requestId: string) => {
    const scan = scanHistory.find(s => s.request_id === requestId);
    if (!scan || !scan.batch_id) {
      showMessage('Could not find batch to load.', 'error');
      return;
    }

    try {
      const details = await loadBatchDetails(apiBaseUrl, scan.batch_id);
      if (details && details.length > 0) {
        setScanHistory(prev => prev.map(s => 
          s.request_id === requestId
            ? { ...s, detailedResults: details }
            : s
        ));
        setViewingResultsFor(requestId);
      } else {
        showMessage('No details found for this batch.', 'warning');
      }
    } catch (error) {
      showMessage('Failed to load batch details.', 'error');
    }
  };
  const calculateSecurityScore = (result: any) => {
    if (result.scan_status !== 'success') return 0;
  
    // Prioritize new PQC analysis
    if (result.raw_response?.pqc_analysis) {
      return result.raw_response.pqc_analysis.overall_score;
    }
  
    // Fallback to quantum_score
    if (result.quantum_score !== undefined) {
      return result.quantum_score;
    }
  
    // Original calculation as last resort
    let score = 0;
    if (result.tls_version?.includes('TLS 1.3')) score += 25;
    else if (result.tls_version?.includes('TLS 1.2')) score += 20;
    
    const keySize = result.public_key_size_bits || 0;
    if (keySize >= 4096) score += 20;
    else if (keySize >= 2048) score += 15;
    
    if (result.ephemeral_key_exchange) score += 15;
    if (result.ct_present) score += 10;
    
    return Math.max(0, Math.min(score, 100));
  };

  const getSecurityIndicator = (result: any) => {
    const grade = result.quantum_grade;
    if (!grade && result.raw_response?.pqc_analysis?.overall_grade) {
      return getGradeColor(result.raw_response.pqc_analysis.overall_grade);
    } else if (grade) {
      return getGradeColor(grade);
    } else {
      const score = calculateSecurityScore(result);
      if (score >= 80) return 'bg-green-500';
      if (score >= 60) return 'bg-yellow-500';
      return 'bg-red-500';
    }
  };

  const cardVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -20 },
  };

  // Check if viewing results - if yes, show detail page instead of history
  if (viewingResultsFor) {
    const scanToView = scanHistory.find(s => s.request_id === viewingResultsFor);
    if (scanToView) {
      return (
        <ResultsDetailPage
          scan={scanToView}
          onBack={() => setViewingResultsFor(null)}
        />
      );
    }
  }
  
  // Otherwise show normal UI
  return (
    <motion.div
      variants={cardVariants}
      initial="hidden"
      animate="visible"
      exit="exit"
      transition={{ duration: 0.3 }}
      className="p-4 sm:p-6"
    >
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-4">
          <div className="p-3 bg-blue-100 dark:bg-blue-900/30 rounded-lg">
            <Globe className="h-8 w-8 text-blue-600 dark:text-blue-400" />
          </div>
          <div>
            <h1 className="text-2xl font-bold">Web Scan</h1>
            <p className="text-muted-foreground">Scan your web assets for cryptographic vulnerabilities</p>
          </div>
        </div>
        <Button variant="outline" onClick={onBack}>
          <ArrowLeft className="h-4 w-4 mr-2" /> Back to Dashboard
        </Button>
      </div>

      {message && (
        <motion.div
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -10 }}
          className={`mb-6 p-4 rounded-lg ${
            message.type === 'success' ? 'bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200' :
            message.type === 'error' ? 'bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-200' :
            message.type === 'warning' ? 'bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-200' :
            'bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200'
          }`}
        >
          {message.text}
        </motion.div>
      )}

      <div className="flex mb-6 border-b">
        <button
          onClick={() => setActiveTab('scan')}
          className={`px-6 py-3 border-b-2 transition-colors ${
            activeTab === 'scan'
              ? 'border-primary text-primary'
              : 'border-transparent hover:text-primary'
          }`}
        >
          New Scan
        </button>
        <button
          onClick={() => setActiveTab('history')}
          className={`px-6 py-3 border-b-2 transition-colors ${
            activeTab === 'history'
              ? 'border-primary text-primary'
              : 'border-transparent hover:text-primary'
          }`}
        >
          Scan History ({scanHistory.length})
        </button>
      </div>

      <AnimatePresence mode="wait">
        {activeTab === 'scan' ? (
          <motion.div
            key="scan-tab"
            variants={cardVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
            className="space-y-6"
          >
            <div className="grid md:grid-cols-2 gap-6 items-start">
              <Card>
                <CardHeader>
                  <CardTitle>Manually Enter Domains</CardTitle>
                  <CardDescription>
                    Type or paste domains directly.
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <textarea
                    id="urls"
                    value={urls}
                    onChange={(e) => setUrls(e.target.value)}
                    onKeyDown={(e) => { if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) { handleScanSubmit(e as any); } }}
                    placeholder="example.com&#10;google.com, github.com"
                    className="w-full p-3 border rounded-lg min-h-[150px] resize-y bg-background"
                    disabled={!!uploadedFile}
                  />
                  <p className="text-sm text-muted-foreground mt-2">
                    Enter domains separated by <strong>commas</strong>, <strong>spaces</strong>, or <strong>new lines</strong>.
                  </p>
                </CardContent>
              </Card>

              <Card>
                <CardHeader>
                  <CardTitle>Upload a .txt File</CardTitle>
                  <CardDescription>
                    Drag & drop or select a file.
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                      {uploadedFile ? (
                        <div className="p-4 border rounded-lg bg-muted/50 flex items-center justify-between">
                          <div className="flex items-center gap-3 overflow-hidden">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-primary flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                            <span className="font-medium truncate" title={uploadedFile.name}>{uploadedFile.name}</span>
                          </div>
                          <button onClick={removeFile} className="text-muted-foreground hover:text-destructive text-2xl leading-none flex-shrink-0 ml-2">&times;</button>
                        </div>
                      ) : (
                        <div
                          onDrop={handleDrop}
                          onDragOver={handleDragOver}
                          onDragLeave={handleDragLeave}
                          className={`relative border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors ${isDragging ? 'border-primary bg-primary/10' : 'border-border hover:border-primary/50'}`}
                        >
                          <input type="file" accept=".txt" onChange={handleFileInputChange} 
                            className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                            aria-label="Upload domain list file"
                            title="Select a .txt file containing domains"
                          />
                          <div className="flex flex-col items-center justify-center space-y-2 text-muted-foreground">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-4-4V7a4 4 0 014-4h1.586a1 1 0 01.707.293l1.414 1.414a1 1 0 00.707.293H13.5a4 4 0 014 4v1.586a1 1 0 01-.293.707l-1.414 1.414a1 1 0 00-.293.707V16a4 4 0 01-4 4H7z" /></svg>
                            <p><strong>Drag & drop a .txt file</strong></p>
                            <p className="text-sm">or click to select</p>
                          </div>
                        </div>
                      )}
                      <p className="text-sm text-muted-foreground">
                        File must be .txt, &lt; 1MB. One URL per line. Lines starting with # are ignored.
                      </p>
                      </div>
                </CardContent>
              </Card>
            </div>
            <div className="mt-6">
                <Button 
                  onClick={handleScanSubmit}
                  disabled={isScanning || (!urls && !uploadedFile)}
                  className="w-full sm:w-auto"
                >
                  {isScanning ? <RefreshCw className="h-4 w-4 mr-2 animate-spin" /> : <Play className="h-4 w-4 mr-2" />}
                  {isScanning ? 'Scanning...' : 'Start Crypto Scan'}
                </Button>
            </div>
          </motion.div>
        ) : (
          <motion.div
            key="history-tab"
            variants={cardVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
            className="space-y-6"
          >
            <div className="flex items-center justify-between">
              <h3 className="text-lg font-semibold">Scan History</h3>
              <Button 
                variant="outline" 
                onClick={async () => {
                  showMessage('Clearing all scan history...', 'info');
                  
                  try {
                    const success = await clearAllScans(apiBaseUrl);
                    
                    if (success) {
                      setScanHistory([]);
                      showMessage('All scan history deleted successfully', 'success');
                    } else {
                      showMessage('Failed to clear all scans', 'error');
                    }
                  } catch (error) {
                    console.error('Error during clear all:', error);
                    showMessage('Error clearing scan history', 'error');
                  }
                }}
                size="sm"
              >
                Clear All
              </Button>
            </div>

            {scanHistory.length === 0 ? (
              <Card>
                <CardContent className="flex items-center justify-center py-12">
                  <p className="text-muted-foreground">No scans found</p>
                </CardContent>
              </Card>
            ) : (
              <div className="space-y-4">
                {scanHistory.map((scan) => (
                  <Card key={scan.request_id} className="transition-all hover:shadow-md">
                    <CardContent className="p-6">
                      <div className="flex items-center justify-between mb-4">
                        <div className="flex items-center gap-3 flex-1">
                          {getStatusIcon(scan.status)}
                          <div>
                            <h4 className="font-semibold">Request ID: {scan.request_id}</h4>
                            <p className="text-sm text-muted-foreground">
                              {new Date(scan.requested_at).toLocaleString()}
                            </p>
                          </div>
                        </div>
                        <div className="flex items-center gap-2">
                          <span className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${
                            scan.status === 'completed' ? 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-200' :
                            scan.status === 'failed' || scan.error_message ? 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-200' :
                            scan.status === 'processing' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-200' :
                            'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-200'
                          }`}>
                            {scan.status.toUpperCase()}
                          </span>
                          
                          {/* DELETE BUTTON FOR INDIVIDUAL BATCH */}
                          <motion.button
                            whileHover={{ scale: 1.1 }}
                            whileTap={{ scale: 0.9 }}
                            onClick={async () => {
                              const batchId = scan.batch_id || scan.request_id;
                              showMessage('Deleting scan batch...', 'info');
                              
                              const success = await deleteScanBatch(apiBaseUrl, batchId);
                              
                              if (success) {
                                setScanHistory(prev => 
                                  prev.filter(s => s.request_id !== scan.request_id)
                                );
                                showMessage('Scan batch deleted successfully', 'success');
                              } else {
                                showMessage('Failed to delete scan batch', 'error');
                              }
                            }}
                            className="p-2 text-muted-foreground hover:text-destructive hover:bg-destructive/10 rounded-lg transition-colors"
                            title="Delete this scan batch"
                            disabled={false}
                          >
                            <Trash2 className="h-4 w-4" />
                          </motion.button>
                        </div>
                      </div>

                      <div className="grid grid-cols-2 gap-4 mb-4 text-sm">
                        <div>
                          <span className="text-muted-foreground">URLs:</span> {scan.total_urls}
                        </div>
                        <div>
                          <span className="text-muted-foreground">Execution Time:</span> {scan.execution_time_seconds !== undefined ? `${scan.execution_time_seconds} seconds` : 'N/A'}
                        </div>
                      </div>

                      {/* BUTTONS SECTION */}
                      <div className="flex items-center gap-2 flex-wrap">
                        {/* Show progress button only for processing scans */}
                        {scan.status === 'processing' && (
                          <Button
                            variant="outline"
                            onClick={() => toggleProgress(scan.request_id)}
                            size="sm"
                          >
                            {expandedProgress.has(scan.request_id) ? 'Hide' : 'View'} Progress
                          </Button>
                        )}

                        {/* Show summary button when scan has completed and has domain progress data */}
                        {(scan.status === 'completed' || scan.status === 'failed') && scan.finalDomainProgress && (
                          <Button
                            variant="secondary"
                            onClick={() => toggleSummary(scan.request_id)}
                            size="sm"
                          >
                            {expandedSummary.has(scan.request_id) ? 'Hide' : 'View'} Summary
                          </Button>
                        )}

                        {(scan.status === 'completed' || (scan.status === 'failed' && scan.detailedResults)) && (
                          <Button
                            variant="outline"
                            onClick={() => {
                              // If results already loaded, just view them
                              if (scan.detailedResults && scan.detailedResults.length > 0) {
                                setViewingResultsFor(scan.request_id);
                              } else {
                                // Otherwise, load them first
                                handleLoadBatchDetails(scan.request_id);
                              }
                            }}
                            size="sm"
                          >
                            View Results
                            {scan.detailedResults && (
                              (() => {
                                const uniqueDomains: {[key: string]: ScanResult} = {};
                                scan.detailedResults.forEach(result => {
                                  uniqueDomains[result.url] = result;
                                });
                                const uniqueResults = Object.values(uniqueDomains);
                                const successCount = uniqueResults.filter(r => r.scan_status === 'success').length;
                                const failCount = uniqueResults.filter(r => r.scan_status !== 'success').length;

                                return (
                                  <span className="ml-2 text-xs text-muted-foreground">
                                    (
                                      <span className="text-green-500">{successCount}</span>
                                      /
                                      <span className="text-red-500">{failCount}</span>
                                    )
                                  </span>
                                );
                              })()
                            )}
                          </Button>
                        )}
                      </div>

                      {/* PROGRESS DISPLAY */}
                      {scan.status === 'processing' && expandedProgress.has(scan.request_id) && (
                        <motion.div
                          initial={{ opacity: 0, height: 0 }}
                          animate={{ opacity: 1, height: 'auto' }}
                          exit={{ opacity: 0, height: 0 }}
                          className="mt-4 col-span-full"
                        >
                          <ProgressDisplay 
                            scanProgress={scanProgress} 
                            domainProgress={domainProgress}
                            processingDomains={processingDomains}
                            onCancel={handleCancelScan}
                            roundHistory={roundHistory}
                            isCancelling={isCancelling}
                            currentRound={currentRound}
                            isActiveProgress={true}
                          />
                        </motion.div>
                      )}

                      {/* SUMMARY DISPLAY */}
                      {(scan.status === 'completed' || scan.status === 'failed') && expandedSummary.has(scan.request_id) && scan.finalDomainProgress && (
                        <motion.div
                          initial={{ opacity: 0, height: 0 }}
                          animate={{ opacity: 1, height: 'auto' }}
                          exit={{ opacity: 0, height: 0 }}
                          className="mt-4 col-span-full border-t pt-4"
                        >
                          {/* Individual domain results with delete buttons */}
                          <div className="space-y-2">
                            <h5 className="font-semibold text-sm">Individual Results:</h5>
                            {scan.detailedResults?.map((result, idx) => (
                              <div 
                                key={idx} 
                                className="flex items-center justify-between p-3 bg-muted/50 rounded-lg"
                              >
                                <div className="flex items-center gap-3 flex-1 min-w-0">
                                  <div className={`w-2 h-2 rounded-full ${
                                    result.scan_status === 'success' ? 'bg-green-500' : 'bg-red-500'
                                  }`} />
                                  <span className="truncate text-sm">{result.url}</span>
                                </div>
                                <motion.button
                                  whileHover={{ scale: 1.1 }}
                                  whileTap={{ scale: 0.9 }}
                                  onClick={async () => {
                                    if (result.id) {
                                      showMessage(`Deleting ${result.url}...`, 'info');
                                      
                                      const success = await deleteScanResult(apiBaseUrl, result.id);
                                      
                                      if (success) {
                                        setScanHistory(prev =>
                                          prev.map(s =>
                                            s.request_id === scan.request_id
                                              ? {
                                                  ...s,
                                                  detailedResults: s.detailedResults?.filter(r => r.id !== result.id)
                                                }
                                              : s
                                          )
                                        );
                                        showMessage('Result deleted successfully', 'success');
                                      } else {
                                        showMessage('Failed to delete result', 'error');
                                      }
                                    }
                                  }}
                                  className="p-1.5 text-muted-foreground hover:text-destructive hover:bg-destructive/10 rounded transition-colors flex-shrink-0"
                                  title="Delete this result"
                                >
                                  <Trash2 className="h-3.5 w-3.5" />
                                </motion.button>
                              </div>
                            ))}
                          </div>
                        </motion.div>
                      )}

                    </CardContent>
                  </Card>
                ))}
              </div>
            )}
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
};

export default WebScan;

--- File: C:\Users\ASUS\Videos\xencrypt\postgres-init\init.sql ---
-- This script runs automatically when PostgreSQL container starts for the first time
-- It creates the necessary tables if they don't exist

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Grant all privileges to scanuser
GRANT ALL PRIVILEGES ON DATABASE scandb TO scanuser;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO scanuser;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO scanuser;

-- Note: SQLAlchemy will create the actual tables via models.py
-- This file is just for initial setup and permissions

--- File: C:\Users\ASUS\Videos\xencrypt\scan-service\.dockerignore ---
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
env/
ENV/
.venv

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Git
.git/
.gitignore

# Docker
.dockerignore
Dockerfile
docker-compose.yml

# Documentation
*.md
README.md

# Logs
*.log

# Testing
.pytest_cache/
.coverage
htmlcov/

# Environment files
.env
.env.local

--- File: C:\Users\ASUS\Videos\xencrypt\scan-service\crypto_audit.py ---
from fastapi import FastAPI, HTTPException, Query, Path
from fastapi.responses import StreamingResponse
from pydantic import BaseModel, Field, validator
import base64
from cryptography import x509
import subprocess
import json, sys
import asyncio
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Dict, Any, Union, Optional
from tls import PQCAnalyzer
from datetime import datetime
from fastapi.middleware.cors import CORSMiddleware
from enum import Enum
import time
import socket
from cryptography.hazmat.backends import default_backend
import requests
from urllib.parse import urlparse
from db_handler import DatabaseHandler

if sys.version_info >= (3, 8):
    from typing import overload, TypeVar
else:
    from typing_extensions import overload, TypeVar

# Initialize PQC Analyzer (reusable instance)
pqc_analyzer = PQCAnalyzer()
# Initialize database handler (add after pqc_analyzer initialization)
db_handler = DatabaseHandler()

app = FastAPI(title="SSL Labs Scan Service", version="5.0")


class RateLimitException(Exception):
    """Custom exception for SSL Labs rate limiting."""
    pass

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class ScanStatus(str, Enum):
    PENDING = "pending"
    SCANNING = "scanning"
    SUCCESS = "success"
    FAILED = "failed"
    RETRYING = "retrying"

class ScanRequest(BaseModel):
    domain: str
    max_concurrent: int = 5
    save_to_db: bool = True  # ADD THIS LINE - option to save to database
    
    @validator('domain')
    def validate_and_parse_domains(cls, v):
        """Parse comma-separated domains and clean them."""
        if ',' in v:
            domains = [d.strip() for d in v.split(',')]
        else:
            domains = [v.strip()]
        
        cleaned = []
        for domain in domains:
            domain = domain.lower()
            domain = domain.replace("https://", "").replace("http://", "").rstrip("/")
            if domain and domain not in cleaned:
                cleaned.append(domain)
        
        if not cleaned:
            raise ValueError("No valid domains provided")
        
        return ','.join(cleaned)

# In-memory retry state (no file storage)
class RetryState:
    def __init__(self):
        self.successful_domains: List[Dict[str, Any]] = []
        self.failed_domains: Dict[str, Dict[str, Any]] = {}  # domain -> error info
        self.current_round: int = 0
        self.total_rounds: int = 0
        self.total_processed: int = 0  # âœ… Add this
        
    def add_success(self, result: Dict[str, Any]):
        self.successful_domains.append(result)
    
    def add_failure(self, domain: str, error: str, attempt: int):
        self.failed_domains[domain] = {
            "domain": domain,
            "error": error,
            "last_attempt": attempt,
            "first_failed_at": self.failed_domains.get(domain, {}).get("first_failed_at", datetime.now().isoformat())
        }
    
    def get_failed_domains(self) -> List[str]:
        return list(self.failed_domains.keys())
    
    def remove_success(self, domain: str):
        if domain in self.failed_domains:
            del self.failed_domains[domain]
    
    def clear(self):
        self.successful_domains.clear()
        self.failed_domains.clear()
        self.current_round = 0
        self.total_processed = 0

# Global dictionary to track cancellation requests
scan_cancellations: Dict[str, bool] = {}

def mark_scan_cancelled(request_id: str):
    scan_cancellations[request_id] = True

def is_scan_cancelled(request_id: str) -> bool:
    return scan_cancellations.get(request_id, False)

def clear_cancellation(request_id: str):
    if request_id in scan_cancellations:
        del scan_cancellations[request_id]


def extract_encryption_algorithm(cipher_name: str) -> str:
    """Extract encryption algorithm from cipher suite name."""
    if "AES_128_GCM" in cipher_name:
        return "AES-128-GCM"
    elif "AES_256_GCM" in cipher_name:
        return "AES-256-GCM"
    elif "AES_128_CBC" in cipher_name:
        return "AES-128-CBC"
    elif "AES_256_CBC" in cipher_name:
        return "AES-256-CBC"
    elif "CHACHA20_POLY1305" in cipher_name:
        return "ChaCha20-Poly1305"
    return "Unknown"

def extract_key_exchange(cipher_name: str, kx_type: Optional[str] = None) -> str:
    """Extract key exchange algorithm from cipher suite name."""
    if "ECDHE" in cipher_name:
        return "ECDHE"
    elif kx_type == "ECDH":
        return "ECDH"
    elif "RSA" in cipher_name and "ECDHE" not in cipher_name:
        return "RSA"
    return "Unknown"

def extract_authentication(cipher_name: str) -> str:
    """Extract authentication algorithm from cipher suite name."""
    if "RSA" in cipher_name:
        return "RSA"
    return "Unknown"

def dict_to_tuple(d: Dict[str, Any]) -> tuple:
    """Convert dictionary to tuple for hashable comparison."""
    items = []
    for k, v in sorted(d.items()):
        if isinstance(v, dict):
            items.append((k, dict_to_tuple(v)))
        elif isinstance(v, list):
            items.append((k, tuple(v) if all(isinstance(i, (str, int, float, bool, type(None))) for i in v) else str(v)))
        else:
            items.append((k, v))
    return tuple(items)

T = TypeVar("T")

@overload
def remove_duplicates_from_structure(obj: Dict[str, Any]) -> Dict[str, Any]: ...
@overload
def remove_duplicates_from_structure(obj: List[T]) -> List[T]: ...
@overload
def remove_duplicates_from_structure(obj: T) -> T: ...

def remove_duplicates_from_structure(obj: Any) -> Any:
    """Recursively traverse the entire data structure and remove duplicates from all lists."""
    if isinstance(obj, dict):
        result = {}
        for key, value in obj.items():
            result[key] = remove_duplicates_from_structure(value)
        return result
    elif isinstance(obj, list):
        if obj and isinstance(obj[0], dict):
            seen = set()
            unique_items = []
            for item in obj:
                cleaned_item = remove_duplicates_from_structure(item)
                if isinstance(cleaned_item, dict):
                    item_tuple = dict_to_tuple(cleaned_item)
                    if item_tuple not in seen:
                        seen.add(item_tuple)
                        unique_items.append(cleaned_item)
            return unique_items
        elif obj and isinstance(obj[0], (str, int, float)):
            return list(dict.fromkeys(obj))
        else:
            return [remove_duplicates_from_structure(item) for item in obj]
    else:
        return obj

def transform_tls12_cipher_suite(suite: Dict[str, Any], position: int = 0) -> Dict[str, Any]:
    """Transform TLS 1.2 cipher suite to desired format."""
    result = {
        "name": suite.get("name", ""),
        "encryption": extract_encryption_algorithm(suite.get("name", "")),
        "key_exchange": extract_key_exchange(suite.get("name", ""), suite.get("kxType")),
        "authentication": extract_authentication(suite.get("name", ""))
    }
    
    if "namedGroupName" in suite:
        result["curve"] = suite["namedGroupName"]
        result["curve_bits"] = suite.get("namedGroupBits", 0)
    
    # Score this algorithm for PQC
    kex_algo = result.get("key_exchange", "")
    if kex_algo:
        kex_score = pqc_analyzer.score_individual_algorithm(
            kex_algo, "kex", 
            curve_bits=result.get("curve_bits"),
            curve=result.get("curve"),
            position=position
        )
        result["kex_pqc_score"] = kex_score.final_score
        result["kex_pqc_grade"] = kex_score.grade
        result["kex_is_pqc"] = kex_score.is_pqc
        result["kex_is_hybrid"] = kex_score.is_hybrid
        result["kex_quantum_safe"] = kex_score.quantum_safe
    
    # Score encryption algorithm
    encryption = result.get("encryption", "")
    if encryption:
        key_size = 256 if "256" in encryption else (192 if "192" in encryption else 128)
        enc_score = pqc_analyzer.score_individual_algorithm(
            encryption, "symmetric", 
            key_size=key_size,
            position=position
        )
        result["encryption_pqc_score"] = enc_score.final_score
        result["encryption_pqc_grade"] = enc_score.grade
    
    return result

def transform_tls13_cipher_suite(suite: Dict[str, Any], position: int = 0) -> Dict[str, Any]:
    """Transform TLS 1.3 cipher suite to desired format."""
    result = {
        "name": suite.get("name", ""),
        "encryption": extract_encryption_algorithm(suite.get("name", "")),
        "key_exchange": suite.get("namedGroupName", ""),
        "curve_bits": suite.get("namedGroupBits", 0)
    }
    # Score KEX
    kex = result.get("key_exchange", "")
    if kex:
        kex_score = pqc_analyzer.score_individual_algorithm(
            kex, "kex",
            curve_bits=result.get("curve_bits"),
            curve=kex,
            position=position
        )
        result["kex_pqc_score"] = kex_score.final_score
        result["kex_pqc_grade"] = kex_score.grade
        result["kex_is_pqc"] = kex_score.is_pqc
        result["kex_is_hybrid"] = kex_score.is_hybrid
        result["kex_quantum_safe"] = kex_score.quantum_safe
    
    # Score encryption
    encryption = result.get("encryption", "")
    if encryption:
        key_size = 256 if "256" in encryption else (192 if "192" in encryption else 128)
        enc_score = pqc_analyzer.score_individual_algorithm(
            encryption, "symmetric",
            key_size=key_size,
            position=position
        )
        result["encryption_pqc_score"] = enc_score.final_score
        result["encryption_pqc_grade"] = enc_score.grade
    
    return result

def transform_named_group(group: Dict[str, Any], position: int = 0) -> Dict[str, Any]:
    """Transform named group/curve to desired format with PQC scoring."""
    curve_name = group.get("name", "")
    curve_bits = group.get("bits", 0)
    
    # âœ… ADD: Score the curve as a key exchange algorithm
    curve_score = pqc_analyzer.score_individual_algorithm(
        curve_name,
        "kex",
        curve=curve_name,
        curve_bits=curve_bits,
        position=position
    )
    
    return {
        "name": curve_name,
        "type": group.get("namedGroupType", ""),
        "bits": curve_bits,
        # âœ… ADD: PQC fields
        "curve_pqc_score": curve_score.final_score,
        "curve_pqc_grade": curve_score.grade,
        "curve_is_pqc": curve_score.is_pqc,
        "curve_is_hybrid": curve_score.is_hybrid,
        "curve_quantum_safe": curve_score.quantum_safe,
    }

def identify_certificate_role(cert: Dict[str, Any], index: int, total: int) -> str:
    """Identify the role of a certificate in the chain."""
    subject = cert.get("subject", "")
    issuer = cert.get("issuerSubject", "")

    if index == 0:
        return "leaf"
    elif subject == issuer:
        return "root"
    else:
        return "intermediate"

def transform_certificate(cert: Dict[str, Any], role: str, position: int = 0) -> Dict[str, Any]:
    """Transform certificate to desired format based on role."""
    key_alg = cert.get("keyAlg", "")
    key_size = cert.get("keySize", 0)

    # âœ… ADD: Score the public key algorithm
    key_score = pqc_analyzer.score_individual_algorithm(
        pqc_analyzer.parse_signature_algorithm(key_alg) if key_alg else "RSA",
        "signature",
        key_size=key_size,
        position=position
    )

    if role == "leaf":
        cn = cert.get("commonNames", [""])[0] if cert.get("commonNames") else ""
        sig_alg = cert.get("sigAlg", "")
        key_alg = cert.get("keyAlg", "")
        key_size = cert.get("keySize", 0)
        
        return {
            "certificate": f"{cn}_{sig_alg.replace('with', '_').replace('RSA', 'RSA')}_{key_size}",
            "subject_alternative_names": cert.get("altNames", []),
            "certificate_transparency": cert.get("sct", False),
            # âœ… ADD: PQC fields
            "cert_pqc_score": key_score.final_score,
            "cert_pqc_grade": key_score.grade,
            "cert_is_pqc": key_score.is_pqc,
            "cert_is_hybrid": key_score.is_hybrid,
            "cert_quantum_safe": key_score.quantum_safe,
        }
    else:
        # For intermediate and root certificates
        return {
            "public_key_algorithm": cert.get("keyAlg", ""),
            "public_key_size": cert.get("keySize", 0),
            # âœ… ADD: PQC fields
            "cert_pqc_score": key_score.final_score,
            "cert_pqc_grade": key_score.grade,
            "cert_is_pqc": key_score.is_pqc,
            "cert_is_hybrid": key_score.is_hybrid,
            "cert_quantum_safe": key_score.quantum_safe,
        }

def safe_get_endpoint(result_data: Dict[str, Any]) -> Dict[str, Any]:
    """Safely extract endpoint data with fallback to empty dict."""
    endpoints = result_data.get("endpoints", [])
    return endpoints[0] if endpoints else {}

def transform_scan_result(data: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Transform the entire scan result to the desired structure."""
    if not data or len(data) == 0:
        raise ValueError("No scan data available")
    
    result_data = data[0]
    endpoint = safe_get_endpoint(result_data)  # âœ… Safe extraction
    details = endpoint.get("details", {})
    
    domain = result_data.get("host", "").replace("https://", "").replace("http://", "").rstrip("/")
    
    transformed = {
        "domain": domain,
        "server_ip": endpoint.get("ipAddress", ""),
        "port": result_data.get("port", 443),
        "tls_configuration": {}
    }
    
    # If no endpoint details, return minimal structure
    if not details:
        transformed["tls_configuration"]["supported_protocols"] = []
        transformed["tls_configuration"]["tls_1.2_cipher_suites"] = {
            "server_preference": "disabled", 
            "suites": []
        }
        transformed["tls_configuration"]["tls_1.3_cipher_suites"] = {
            "server_preference": "disabled", 
            "suites": []
        }
        transformed["tls_configuration"]["supported_elliptic_curves"] = {
            "server_preference": "disabled", 
            "curves": []
        }
        transformed["certificate_chain"] = {
            "leaf_certificate": {},
            "intermediate_certificates": [],
            "root_certificates": [],
            "alternate_certificates": []
        }
        transformed["signature_algorithms"] = {
            "certificate_signatures": [],
            "handshake_signatures": []
        }
        print(f"âš ï¸ Warning: No endpoint details for {domain}, returning minimal data")
        return transformed  # Early return with valid but empty structure
    
    protocols = details.get("protocols", [])
    supported_protocols = [f"TLS {p['version']}" for p in protocols]
    transformed["tls_configuration"]["supported_protocols"] = supported_protocols
    
    suites = details.get("suites", [])
    # Initialize with empty structures
    transformed["tls_configuration"]["tls_1.2_cipher_suites"] = {"server_preference": "disabled", "suites": []}
    transformed["tls_configuration"]["tls_1.3_cipher_suites"] = {"server_preference": "disabled", "suites": []}
    if suites:
        for suite_group in suites:
            protocol_id = suite_group.get("protocol")
            preference = "enabled" if suite_group.get("preference") else "disabled"
            cipher_list = suite_group.get("list", [])
            
            if protocol_id == 771:
                transformed["tls_configuration"]["tls_1.2_cipher_suites"] = {
                    "server_preference": preference,
                    "suites": [transform_tls12_cipher_suite(cs, position=i) for i, cs in enumerate(cipher_list)]
                }
            elif protocol_id == 772:
                transformed["tls_configuration"]["tls_1.3_cipher_suites"] = {
                    "server_preference": preference,
                    "suites": [transform_tls13_cipher_suite(cs, position=i) for i, cs in enumerate(cipher_list)]
                }
    
    # Add component-level PQC scores for TLS 1.2
    if transformed["tls_configuration"]["tls_1.2_cipher_suites"]["suites"]:
        tls12_kex_scores = [s.get("kex_pqc_score", 0) for s in 
                            transformed["tls_configuration"]["tls_1.2_cipher_suites"]["suites"] 
                            if "kex_pqc_score" in s]
        if tls12_kex_scores:
            avg_score = sum(tls12_kex_scores) / len(tls12_kex_scores)
            transformed["tls_configuration"]["tls_1.2_cipher_suites"]["component_kex_score"] = round(avg_score, 2)
            transformed["tls_configuration"]["tls_1.2_cipher_suites"]["component_kex_grade"] = pqc_analyzer.score_to_grade(avg_score)
    
    # Add component-level PQC scores for TLS 1.3
    if transformed["tls_configuration"]["tls_1.3_cipher_suites"]["suites"]:
        tls13_kex_scores = [s.get("kex_pqc_score", 0) for s in 
                            transformed["tls_configuration"]["tls_1.3_cipher_suites"]["suites"] 
                            if "kex_pqc_score" in s]
        if tls13_kex_scores:
            avg_score = sum(tls13_kex_scores) / len(tls13_kex_scores)
            transformed["tls_configuration"]["tls_1.3_cipher_suites"]["component_kex_score"] = round(avg_score, 2)
            transformed["tls_configuration"]["tls_1.3_cipher_suites"]["component_kex_grade"] = pqc_analyzer.score_to_grade(avg_score)
    
    named_groups = details.get("namedGroups", {})
    transformed["tls_configuration"]["supported_elliptic_curves"] = {"server_preference": "disabled", "curves": []}
    if named_groups:
        transformed["tls_configuration"]["supported_elliptic_curves"] = {
            "server_preference": "enabled" if named_groups.get("preference") else "disabled",
            "curves": [transform_named_group(ng, position=i) for i, ng in enumerate(named_groups.get("list", []))]
        }
    
    certs = result_data.get("certs", [])
    certificate_chain = {
        "leaf_certificate": {},
        "intermediate_certificates": [],
        "root_certificates": [],
        "alternate_certificates": []
    }
    
    if certs:
        if len(certs) > 0:
            certificate_chain["leaf_certificate"] = transform_certificate(certs[0], "leaf", position=0)
        
        for i in range(1, len(certs)):
            cert = certs[i]
            role = identify_certificate_role(cert, i, len(certs))
            transformed_cert = transform_certificate(cert, role, position=i)
            
            if role == "intermediate":
                certificate_chain["intermediate_certificates"].append(transformed_cert)
            elif role == "root":
                certificate_chain["root_certificates"].append(transformed_cert)
            else:
                certificate_chain["alternate_certificates"].append(transformed_cert)
    
    transformed["certificate_chain"] = certificate_chain
    
    # Add the new signature algorithms section
    transformed["signature_algorithms"] = {
        "certificate_signatures": extract_signature_algorithms_from_certs(certs),
        "handshake_signatures": extract_handshake_signature_algorithms(details)
    }
    
    transformed = remove_duplicates_from_structure(transformed)
    
    return transformed

def extract_signature_algorithms_from_certs(certs: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Extract signature algorithms from SSL Labs certificate data with PQC scoring."""
    results = []
    
    for i, cert in enumerate(certs):
        try:
            # Try to parse raw certificate first
            raw_cert = cert.get("raw")
            
            if raw_cert:
                try:
                    # Decode base64 certificate
                    der_cert = base64.b64decode(raw_cert)
                    x509_cert = x509.load_der_x509_certificate(der_cert, default_backend())
                    
                    # Extract signature algorithm
                    sig_hash_alg = x509_cert.signature_hash_algorithm
                    pubkey = x509_cert.public_key()
                    pubkey_type = type(pubkey).__name__.replace('PublicKey', '')
                    
                    if sig_hash_alg:
                        hash_name = sig_hash_alg.name.upper()
                        sig_algorithm = f"{hash_name}with{pubkey_type}"
                    else:
                        sig_algorithm = f"UNKNOWNwith{pubkey_type}"
                    
                    # âœ… ADD: Score the signature algorithm
                    sig_score = pqc_analyzer.score_individual_algorithm(
                        pqc_analyzer.parse_signature_algorithm(sig_algorithm),
                        "signature",
                        key_size=cert.get("keySize", 0),
                        position=i
                    )
                    
                    # âœ… ADD: Score the hash algorithm
                    hash_score = pqc_analyzer.score_individual_algorithm(
                        hash_name if sig_hash_alg else "SHA256",
                        "hash",
                        position=i
                    )
                    
                    results.append({
                        "position": i,
                        "certificate_subject": cert.get("subject", "Unknown"),
                        "signature_algorithm": sig_algorithm,
                        "hash_algorithm": sig_hash_alg.name.upper() if sig_hash_alg else "UNKNOWN",
                        "public_key_type": pubkey_type,
                        "public_key_size": cert.get("keySize", 0),
                        "signature_algorithm_oid": x509_cert.signature_algorithm_oid.dotted_string if x509_cert.signature_algorithm_oid else None,
                        # âœ… ADD: PQC fields for signature
                        "sig_pqc_score": sig_score.final_score,
                        "sig_pqc_grade": sig_score.grade,
                        "sig_is_pqc": sig_score.is_pqc,
                        "sig_is_hybrid": sig_score.is_hybrid,
                        "sig_quantum_safe": sig_score.quantum_safe,
                        # âœ… ADD: PQC fields for hash
                        "hash_pqc_score": hash_score.final_score,
                        "hash_pqc_grade": hash_score.grade,
                    })
                    continue
                    
                except Exception as e:
                    print(f"âš ï¸ Failed to parse raw cert at position {i}: {e}")
            
            # Fallback: Use SSL Labs provided data
            sig_alg = cert.get("sigAlg", "Unknown")
            hash_alg = sig_alg.split("with")[0] if "with" in sig_alg else "SHA256"
            
            # âœ… ADD: Score with fallback data
            sig_score = pqc_analyzer.score_individual_algorithm(
                pqc_analyzer.parse_signature_algorithm(sig_alg),
                "signature",
                key_size=cert.get("keySize", 0),
                position=i
            )
            
            hash_score = pqc_analyzer.score_individual_algorithm(
                pqc_analyzer.parse_hash_algorithm(hash_alg),
                "hash",
                position=i
            )
            
            results.append({
                "position": i,
                "certificate_subject": cert.get("subject", "Unknown"),
                "signature_algorithm": sig_alg,
                "hash_algorithm": hash_alg,
                "public_key_type": cert.get("keyAlg", "Unknown"),
                "public_key_size": cert.get("keySize", 0),
                # âœ… ADD: PQC fields
                "sig_pqc_score": sig_score.final_score,
                "sig_pqc_grade": sig_score.grade,
                "sig_is_pqc": sig_score.is_pqc,
                "sig_is_hybrid": sig_score.is_hybrid,
                "sig_quantum_safe": sig_score.quantum_safe,
                "hash_pqc_score": hash_score.final_score,
                "hash_pqc_grade": hash_score.grade,
            })
            
        except Exception as e:
            print(f"âŒ Error extracting signature from cert {i}: {e}")
            results.append({
                "position": i,
                "error": str(e)
            })
    
    return results


def extract_handshake_signature_algorithms(details: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Extract supported signature algorithms from SSL Labs scan details with PQC scoring."""
    supported = []
    seen = set()
    
    suites = details.get("suites", [])
    
    # Check TLS 1.2 cipher suites
    for suite_group in suites:
        if suite_group.get("protocol") == 771:  # TLS 1.2
            for cipher in suite_group.get("list", []):
                cipher_name = cipher.get("name", "")
                
                # ECDSA signature algorithms
                if "ECDSA" in cipher_name:
                    if "SHA256" in cipher_name and "ecdsa_sha256_tls12" not in seen:
                        algo_name = "ecdsa_secp256r1_sha256"
                        # âœ… ADD: Score this algorithm
                        sig_score = pqc_analyzer.score_individual_algorithm(
                            pqc_analyzer.parse_signature_algorithm(algo_name),
                            "signature",
                            position=len(supported)
                        )
                        
                        supported.append({
                            "algorithm": algo_name,
                            "protocol": "TLS 1.2",
                            # âœ… ADD: PQC fields
                            "sig_pqc_score": sig_score.final_score,
                            "sig_pqc_grade": sig_score.grade,
                            "sig_is_pqc": sig_score.is_pqc,
                            "sig_is_hybrid": sig_score.is_hybrid,
                            "sig_quantum_safe": sig_score.quantum_safe,
                        })
                        seen.add("ecdsa_sha256_tls12")
                    
                    if "SHA384" in cipher_name and "ecdsa_sha384_tls12" not in seen:
                        algo_name = "ecdsa_secp384r1_sha384"
                        sig_score = pqc_analyzer.score_individual_algorithm(
                            pqc_analyzer.parse_signature_algorithm(algo_name),
                            "signature",
                            position=len(supported)
                        )
                        
                        supported.append({
                            "algorithm": algo_name,
                            "protocol": "TLS 1.2",
                            "sig_pqc_score": sig_score.final_score,
                            "sig_pqc_grade": sig_score.grade,
                            "sig_is_pqc": sig_score.is_pqc,
                            "sig_is_hybrid": sig_score.is_hybrid,
                            "sig_quantum_safe": sig_score.quantum_safe,
                        })
                        seen.add("ecdsa_sha384_tls12")
                
                # RSA signature algorithms
                if "RSA" in cipher_name and "ECDHE" in cipher_name:
                    if "SHA256" in cipher_name and "rsa_sha256_tls12" not in seen:
                        algo_name = "rsa_pkcs1_sha256"
                        sig_score = pqc_analyzer.score_individual_algorithm(
                            pqc_analyzer.parse_signature_algorithm(algo_name),
                            "signature",
                            position=len(supported)
                        )
                        
                        supported.append({
                            "algorithm": algo_name,
                            "protocol": "TLS 1.2",
                            "sig_pqc_score": sig_score.final_score,
                            "sig_pqc_grade": sig_score.grade,
                            "sig_is_pqc": sig_score.is_pqc,
                            "sig_is_hybrid": sig_score.is_hybrid,
                            "sig_quantum_safe": sig_score.quantum_safe,
                        })
                        seen.add("rsa_sha256_tls12")
                    
                    if "SHA384" in cipher_name and "rsa_sha384_tls12" not in seen:
                        algo_name = "rsa_pkcs1_sha384"
                        sig_score = pqc_analyzer.score_individual_algorithm(
                            pqc_analyzer.parse_signature_algorithm(algo_name),
                            "signature",
                            position=len(supported)
                        )
                        
                        supported.append({
                            "algorithm": algo_name,
                            "protocol": "TLS 1.2",
                            "sig_pqc_score": sig_score.final_score,
                            "sig_pqc_grade": sig_score.grade,
                            "sig_is_pqc": sig_score.is_pqc,
                            "sig_is_hybrid": sig_score.is_hybrid,
                            "sig_quantum_safe": sig_score.quantum_safe,
                        })
                        seen.add("rsa_sha384_tls12")
    
    # Check TLS 1.3 cipher suites
    for suite_group in suites:
        if suite_group.get("protocol") == 772:  # TLS 1.3
            # TLS 1.3 uses different signature schemes
            if "rsa_pss_sha256" not in seen:
                algo_name = "rsa_pss_rsae_sha256"
                sig_score = pqc_analyzer.score_individual_algorithm(
                    pqc_analyzer.parse_signature_algorithm(algo_name),
                    "signature",
                    position=len(supported)
                )
                
                supported.append({
                    "algorithm": algo_name,
                    "protocol": "TLS 1.3",
                    "sig_pqc_score": sig_score.final_score,
                    "sig_pqc_grade": sig_score.grade,
                    "sig_is_pqc": sig_score.is_pqc,
                    "sig_is_hybrid": sig_score.is_hybrid,
                    "sig_quantum_safe": sig_score.quantum_safe,
                })
                seen.add("rsa_pss_sha256")
            
            if "ecdsa_sha256_tls13" not in seen:
                algo_name = "ecdsa_secp256r1_sha256"
                sig_score = pqc_analyzer.score_individual_algorithm(
                    pqc_analyzer.parse_signature_algorithm(algo_name),
                    "signature",
                    position=len(supported)
                )
                
                supported.append({
                    "algorithm": algo_name,
                    "protocol": "TLS 1.3",
                    "sig_pqc_score": sig_score.final_score,
                    "sig_pqc_grade": sig_score.grade,
                    "sig_is_pqc": sig_score.is_pqc,
                    "sig_is_hybrid": sig_score.is_hybrid,
                    "sig_quantum_safe": sig_score.quantum_safe,
                })
                seen.add("ecdsa_sha256_tls13")
            
            if "ecdsa_sha384_tls13" not in seen:
                algo_name = "ecdsa_secp384r1_sha384"
                sig_score = pqc_analyzer.score_individual_algorithm(
                    pqc_analyzer.parse_signature_algorithm(algo_name),
                    "signature",
                    position=len(supported)
                )
                
                supported.append({
                    "algorithm": algo_name,
                    "protocol": "TLS 1.3",
                    "sig_pqc_score": sig_score.final_score,
                    "sig_pqc_grade": sig_score.grade,
                    "sig_is_pqc": sig_score.is_pqc,
                    "sig_is_hybrid": sig_score.is_hybrid,
                    "sig_quantum_safe": sig_score.quantum_safe,
                })
                seen.add("ecdsa_sha384_tls13")
    
    # If nothing found, provide defaults based on what ciphers exist
    if not supported:
        algo_name = "rsa_pkcs1_sha256"
        sig_score = pqc_analyzer.score_individual_algorithm(
            pqc_analyzer.parse_signature_algorithm(algo_name),
            "signature",
            position=0
        )
        
        supported.append({
            "algorithm": algo_name,
            "protocol": "TLS 1.2",
            "sig_pqc_score": sig_score.final_score,
            "sig_pqc_grade": sig_score.grade,
            "sig_is_pqc": sig_score.is_pqc,
            "sig_is_hybrid": sig_score.is_hybrid,
            "sig_quantum_safe": sig_score.quantum_safe,
        })
    
    return supported

def transform_scan_result_old(data: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Transform the entire scan result to the desired structure."""
    if not data or len(data) == 0:
        raise ValueError("No scan data available")
    
    result_data = data[0]
    endpoint = safe_get_endpoint(result_data)  # âœ… Safe extraction
    details = endpoint.get("details", {})
    
    domain = result_data.get("host", "").replace("https://", "").replace("http://", "").rstrip("/")
    
    transformed = {
        "domain": domain,
        "server_ip": endpoint.get("ipAddress", ""),
        "port": result_data.get("port", 443),
        "tls_configuration": {}
    }
    
    # If no endpoint details, return minimal structure
    if not details:
        transformed["tls_configuration"]["supported_protocols"] = []
        transformed["tls_configuration"]["tls_1.2_cipher_suites"] = {
            "server_preference": "disabled", 
            "suites": []
        }
        transformed["tls_configuration"]["tls_1.3_cipher_suites"] = {
            "server_preference": "disabled", 
            "suites": []
        }
        transformed["tls_configuration"]["supported_elliptic_curves"] = {
            "server_preference": "disabled", 
            "curves": []
        }
        transformed["certificate_chain"] = {
            "leaf_certificate": {},
            "intermediate_certificates": [],
            "root_certificates": [],
            "alternate_certificates": []
        }
        print(f"âš ï¸ Warning: No endpoint details for {domain}, returning minimal data")
        return transformed  # Early return with valid but empty structure
    
    protocols = details.get("protocols", [])
    supported_protocols = [f"TLS {p['version']}" for p in protocols]
    transformed["tls_configuration"]["supported_protocols"] = supported_protocols
    
    suites = details.get("suites", [])
    # Initialize with empty structures
    transformed["tls_configuration"]["tls_1.2_cipher_suites"] = {"server_preference": "disabled", "suites": []}
    transformed["tls_configuration"]["tls_1.3_cipher_suites"] = {"server_preference": "disabled", "suites": []}
    if suites:
        for suite_group in suites:
            protocol_id = suite_group.get("protocol")
            preference = "enabled" if suite_group.get("preference") else "disabled"
            cipher_list = suite_group.get("list", [])
            
            if protocol_id == 771:
                transformed["tls_configuration"]["tls_1.2_cipher_suites"] = {
                    "server_preference": preference,
                    "suites": [transform_tls12_cipher_suite(cs) for cs in cipher_list]
                }
            elif protocol_id == 772:
                transformed["tls_configuration"]["tls_1.3_cipher_suites"] = {
                    "server_preference": preference,
                    "suites": [transform_tls13_cipher_suite(cs) for cs in cipher_list]
                }
    
    named_groups = details.get("namedGroups", {})
    transformed["tls_configuration"]["supported_elliptic_curves"] = {"server_preference": "disabled", "curves": []}
    if named_groups:
        transformed["tls_configuration"]["supported_elliptic_curves"] = {
            "server_preference": "enabled" if named_groups.get("preference") else "disabled",
            "curves": [transform_named_group(ng, position=i) for i, ng in enumerate(named_groups.get("list", []))]
        }
    
    certs = result_data.get("certs", [])
    certificate_chain = {
        "leaf_certificate": {},
        "intermediate_certificates": [],
        "root_certificates": [],
        "alternate_certificates": []
    }
    
    if certs:
        if len(certs) > 0:
            certificate_chain["leaf_certificate"] = transform_certificate(certs[0], "leaf", position=0)
        
        for i in range(1, len(certs)):
            cert = certs[i]
            role = identify_certificate_role(cert, i, len(certs))
            transformed_cert = transform_certificate(cert, role, position=i)
            
            if role == "intermediate":
                certificate_chain["intermediate_certificates"].append(transformed_cert)
            elif role == "root":
                certificate_chain["root_certificates"].append(transformed_cert)
            else:
                certificate_chain["alternate_certificates"].append(transformed_cert)
    
    transformed["certificate_chain"] = certificate_chain
    # transformed = remove_duplicates_from_structure(transformed)
    
    return transformed

def clear_ssllabs_cache():
    """Clear SSL Labs cache by running with --nocache flag."""
    try:
        print("ðŸ§¹ Clearing SSL Labs cache...")
        # Just a marker - actual clearing happens by using fresh scans
        return True
    except Exception as e:
        print(f"âš ï¸ Cache clear warning: {e}")
        return False

def quick_domain_check(domain: str, timeout: int = 5) -> tuple[bool, str]:
    """
    OPTIONAL: Only check if domain resolves via DNS, don't make HTTP requests.
    This avoids anti-bot protection while catching typos/offline servers.
    """
    try:
        socket.gethostbyname(domain.split('/')[0])  # Just DNS lookup
        return True, ""
    except socket.gaierror:
        return False, f"Domain '{domain}' does not exist (DNS lookup failed)"
    except Exception as e:
        # If DNS works, assume domain is reachable
        return True, ""

def safe_get_first_item(items: List[Any], default: Any = None) -> Any:
    """Safely get first item from list or return default."""
    if default is None:
        default = {}
    return items[0] if items else default

def format_result_for_frontend(transformed_result: Dict[str, Any], request_id: str) -> Dict[str, Any]:
    """Format scan result to match frontend expectations."""
    tls_config = transformed_result.get("tls_configuration", {})
    cert_chain = transformed_result.get("certificate_chain", {})
    
    # âœ… Safe access to intermediate certificates
    intermediate_cert = safe_get_first_item(
        cert_chain.get("intermediate_certificates", [])
    )
    
    # âœ… Safe access to TLS 1.3 cipher suites
    tls13_suites = tls_config.get("tls_1.3_cipher_suites", {}).get("suites", [])
    tls13_first_suite = safe_get_first_item(tls13_suites)
    
    # âœ… Safe access to TLS 1.2 cipher suites
    tls12_suites = tls_config.get("tls_1.2_cipher_suites", {}).get("suites", [])
    tls12_first_suite = safe_get_first_item(tls12_suites)

    # ðŸ”§ FIX: Ensure raw_response contains the FULL transformed result
    return {
        "request_id": request_id,
        "url": transformed_result.get("domain", ""),
        "status": "completed",
        "requested_at": datetime.now().isoformat(),
        "total_urls": 1,
        "scan_status": "success",
        "tls_version": ", ".join(tls_config.get("supported_protocols", [])),
        "public_key_size_bits": intermediate_cert.get("public_key_size"),
        "cipher_suite_name": tls13_first_suite.get("name") or tls12_first_suite.get("name") or "",
        "cipher_protocol": safe_get_first_item(tls_config.get("supported_protocols", []), ""),
        "cipher_strength_bits": tls13_first_suite.get("curve_bits") or tls12_first_suite.get("curve_bits"),
        "ephemeral_key_exchange": any(
            s.get("key_exchange") == "ECDHE" 
            for s in tls_config.get("tls_1.2_cipher_suites", {}).get("suites", [])
        ),
        "public_key_algorithm": intermediate_cert.get("public_key_algorithm"),
        "ct_present": cert_chain.get("leaf_certificate", {}).get("certificate_transparency", False),
        "quantum_score": transformed_result.get("quantum_score"),
        "quantum_grade": transformed_result.get("quantum_grade"),
        # ðŸ”§ CRITICAL FIX: Store the COMPLETE transformed result including PQC analysis
        "raw_response": transformed_result,  # â† This includes everything: tls_config, cert_chain, pqc_analysis, etc.
        "execution_time_seconds": transformed_result.get("scan_metadata", {}).get("timestamp")
    }

def handle_scan_with_backoff(domain: str, use_cache: bool, attempt: int, timeout: int, max_backoff_retries: int = 3) -> Dict[str, Any]:
    """
    Wrapper that handles rate limiting with exponential backoff.
    Retries only for rate limits, not other errors.
    """
    for retry in range(max_backoff_retries):
        try:
            return process_single_domain(domain, use_cache, attempt, timeout)
        except RateLimitException as e:
            if retry < max_backoff_retries - 1:
                wait_time = (2 ** retry) * 5  # 5s, 10s, 20s
                print(f"â³ Rate limited on {domain}, waiting {wait_time}s (retry {retry + 1}/{max_backoff_retries})")
                time.sleep(wait_time)
                print(f"ðŸ”„ Retrying {domain} after backoff...")  # â† ADD THIS
            else:
                print(f"âŒ Rate limit retries exhausted for {domain}")
                raise HTTPException(status_code=429, detail=f"Rate limit exceeded for {domain}")
        except HTTPException:
            # Don't retry other HTTP errors (503, 504, 500, etc.)
            raise
        except Exception:
            # Don't retry unexpected errors
            raise
    
    # This line should never be reached, but just in case
    raise HTTPException(status_code=500, detail=f"Unexpected error in backoff handler for {domain}")

def run_ssllabs_cli(domain: str, use_cache: bool = True, timeout: int = 300):
    """Run ssllabs-scan CLI tool and return parsed JSON."""
    try:
        print(f"ðŸ” Scanning: {domain} (cache: {use_cache})")
        
        cmd = ["ssllabs-scan", "--quiet"]
        if use_cache:
            cmd.append("--usecache")
        cmd.append(domain)
        
        result = subprocess.run(
            cmd,
            capture_output=True, 
            text=True, 
            check=True,
            timeout=timeout
        )
        return json.loads(result.stdout)
    except subprocess.TimeoutExpired:
        print(f"â±ï¸ Scan timeout for {domain} after {timeout}s - domain may be slow to analyze")
        raise HTTPException(status_code=504, detail=f"Scan timed out for {domain} after {timeout}s")
    except subprocess.CalledProcessError as e:
        error_msg = e.stderr or "Scan failed"
        # More comprehensive rate limit detection
        rate_limit_indicators = [
            "429",
            "rate limit",
            "too many requests",
            "assessment failed: HTTP 429",  # SSL Labs specific
            "service overloaded",
            "throttled",
            "try again later"
        ]
        if any(indicator in error_msg.lower() for indicator in rate_limit_indicators):
            raise RateLimitException(f"Rate limited for {domain}")
        raise HTTPException(status_code=500, detail=f"Scan failed for {domain}: {error_msg}")
    except json.JSONDecodeError as e:
        raise HTTPException(status_code=500, detail=f"Invalid JSON from scan: {str(e)}")
    except FileNotFoundError:
        raise HTTPException(status_code=500, detail="ssllabs-scan not found")

def process_single_domain(domain: str, use_cache: bool = True, attempt: int = 1, timeout: int = 300) -> Dict[str, Any]:
    """Process a single domain scan."""
    try:
        # Only check DNS, not HTTP connectivity
        is_resolvable, error_msg = quick_domain_check(domain, timeout=2)
        if not is_resolvable:
            raise HTTPException(status_code=503, detail=error_msg)
        
        raw_result = run_ssllabs_cli(domain, use_cache=use_cache, timeout=timeout)
        transformed_result = transform_scan_result(raw_result)
        
        # Get PQC analysis - FIX HERE
        data_for_analysis = {
            "url": transformed_result.get("domain", ""),
            "requested_at": datetime.now().isoformat(),
            "raw_response": transformed_result
        }
        pqc_report = pqc_analyzer.analyze_tls_configuration(data_for_analysis)
        
        # Extract scores from the report
        pqc_analysis = {
            "overall_score": pqc_report.overall_score,
            "overall_grade": pqc_report.overall_grade,
            "security_level": pqc_report.security_level,
            "quantum_ready": pqc_report.quantum_ready,
            "hybrid_ready": pqc_report.hybrid_ready,
            "components": {
                comp_name: {
                    "weighted_average": comp.weighted_average,
                    "grade": comp.grade,
                    "pqc_percentage": comp.pqc_percentage,
                    "quantum_safe_count": comp.quantum_safe_count
                }
                for comp_name, comp in pqc_report.components.items()
            }
        }
        
        # Add overall scores to top level (backward compatibility)
        transformed_result["quantum_score"] = pqc_analysis.get("overall_score", 0)
        transformed_result["quantum_grade"] = pqc_analysis.get("overall_grade", "F")
        
        # Add detailed PQC analysis as separate key
        transformed_result["pqc_analysis"] = pqc_analysis
        
        transformed_result = remove_duplicates_from_structure(transformed_result)
        transformed_result["scan_metadata"] = {
            "attempt": attempt,
            "cached": use_cache,
            "timestamp": datetime.now().isoformat()
        }
        
        # Return formatted result for frontend
        request_id = f"{domain}_{int(datetime.now().timestamp())}"
        return format_result_for_frontend(transformed_result, request_id)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error processing {domain}: {str(e)}")

@app.post("/scan")
def scan_domain(request: ScanRequest):
    """
    Enhanced scan with automatic retry logic.
    - Tracks failed domains in memory
    - Retries up to max_retries rounds
    - Clears cache between rounds (optional)
    - Returns all results with metadata
    """
    domains = [d.strip() for d in request.domain.split(',')]
    
    if len(domains) == 1:
        # For a single domain, use a longer default timeout as there are no retries in this path.
        result = process_single_domain(domains[0], timeout=600)
        return result
    
    # Multi-domain with retry logic
    retry_state = RetryState()
    max_retries = 3
    retry_delay = 30
    clear_cache_between_rounds = False
    retry_state.total_rounds = max_retries
    initial_timeout = 600  # 10 minutes
    timeout_increment = 300  # Increase by 5 minutes each round
    
    domains_to_scan = domains.copy()
    # âœ… NEW: Pre-check all domains for connectivity (no retries for offline domains)
    print(f"\nðŸ” Pre-checking connectivity for {len(domains_to_scan)} domains...")
    confirmed_online = []
    confirmed_offline = []
    
    for domain in domains_to_scan:
        is_reachable, error_msg = quick_domain_check(domain, timeout=5)
        if is_reachable:
            confirmed_online.append(domain)
            print(f"âœ… {domain} - Online")
        else:
            confirmed_offline.append({
                "domain": domain,
                "error": error_msg,
                "last_attempt": 0,
                "first_failed_at": datetime.now().isoformat()
            })
            print(f"âŒ {domain} - Offline")
    
    # Add offline domains directly to failed state
    for offline_domain in confirmed_offline:
        retry_state.failed_domains[offline_domain["domain"]] = offline_domain
    
    # Only scan domains that are online
    domains_to_scan = confirmed_online
    
    if not domains_to_scan:
        print("âš ï¸ No domains are online. Skipping scan.")

    for round_num in range(1, max_retries + 1):
        # âœ… NEW: Skip retry loop if no domains to scan
        if not domains_to_scan:
            print("â­ï¸ No domains to scan, skipping round.")
            break
        retry_state.current_round = round_num
        print(f"\n{'='*60}")
        print(f"ðŸ”„ ROUND {round_num}/{max_retries} - Scanning {len(domains_to_scan)} domains")
        print(f"{'='*60}")
        
        # Determine cache usage
        use_cache = (round_num == 1)  # Use cache only in first round
        current_timeout = initial_timeout + (timeout_increment * (round_num - 1))
        
        round_results = []
        round_failures = []
        
        with ThreadPoolExecutor(max_workers=min(2, len(domains_to_scan))) as executor:
            future_to_domain = {
                executor.submit(handle_scan_with_backoff, domain, use_cache, round_num, current_timeout): domain 
                for domain in domains_to_scan
            }
            
            for future in as_completed(future_to_domain):
                domain = future_to_domain[future]
                try:
                    result = future.result()
                    round_results.append(result)
                    retry_state.add_success(result)
                    retry_state.remove_success(domain)
                    print(f"âœ… [{round_num}] Success: {domain}")
                    time.sleep(5)  # âœ… Increase from 3 to 5 seconds
                    
                except HTTPException as e:
                    # Distinguish rate limits from other errors
                    if e.status_code == 429:
                        print(f"ðŸš« [{round_num}] Rate Limited: {domain} - will retry with backoff")
                    retry_state.add_failure(domain, e.detail, round_num)
                    print(f"âŒ [{round_num}] Failed: {domain} - {e.detail}")
                    
                except Exception as e:
                    retry_state.add_failure(domain, str(e), round_num)
                    print(f"âŒ [{round_num}] Failed: {domain} - {str(e)}")
        
        # Update domains to scan for next round
        domains_to_scan = retry_state.get_failed_domains()
        
        # If no failures, we're done
        if not domains_to_scan:
            print(f"ðŸŽ‰ All domains successful after round {round_num}!")
            break
        
        # If more rounds remaining, prepare for retry
        if round_num < max_retries:
            print(f"â³ Waiting {retry_delay}s before retry round {round_num + 1}...")
            print(f"ðŸ“‹ Domains to retry: {', '.join(domains_to_scan)}")
            
            if clear_cache_between_rounds:
                clear_ssllabs_cache()
            
            time.sleep(retry_delay)
    
    # Prepare final response
    final_response = {
        "summary": {
            "total_domains": len(domains),
            "successful": len(retry_state.successful_domains),
            "failed": len(retry_state.failed_domains),
            "rounds_completed": retry_state.current_round,
            "timestamp": datetime.now().isoformat()
        },
        "successful_scans": retry_state.successful_domains,
        "failed_scans": list(retry_state.failed_domains.values()) if retry_state.failed_domains else []
    }
    
    return final_response

@app.post("/scan-with-progress")
async def scan_with_progress(request: ScanRequest):
    """
    Scan domains with live progress updates and retry logic.
    Uses Server-Sent Events for real-time updates.
    """
    
    async def event_stream():
        request_id = f"scan_{int(datetime.now().timestamp())}_{hash(request.domain) % 10000}"
        batch_id = f"batch_{int(datetime.now().timestamp())}"  # ADD THIS
        domains = [d.strip() for d in request.domain.split(',')]
        retry_state = RetryState()
        max_retries = 3
        retry_delay = 30
        clear_cache_between_rounds = False
        retry_state.total_rounds = max_retries
        initial_timeout = 600  # 10 minutes
        timeout_increment = 300  # Increase by 5 minutes each round
        
        start_time = datetime.now()
        
        # Create batch in database if save_to_db is enabled
        if request.save_to_db:
            db_handler.create_scan_batch(batch_id, len(domains), request.max_concurrent)
        
        # Send start event
        start_event = {
            'type': 'start',
            'request_id': request_id,
            'batch_id': batch_id,  # ADD THIS
            'total_domains': len(domains),
            'save_to_db': request.save_to_db,  # ADD THIS
            'max_rounds': max_retries,
            'timestamp': start_time.isoformat()
        }
        yield f"data: {json.dumps(start_event)}\n\n"
        
        domains_to_scan = domains.copy()
        # Pre-check connectivity
        for domain in domains.copy():
            is_reachable, error_msg = quick_domain_check(domain, timeout=5)
            if not is_reachable:
                retry_state.add_failure(domain, error_msg, 0)
                domains_to_scan.remove(domain)
                
                # ADD THIS: Save to database
                if request.save_to_db:
                    db_handler.save_failed_scan(
                        domain, 
                        error_msg, 
                        batch_id, 
                        f"{request_id}_{domain}"
                    )
                
                # Send domain_offline event
                offline_event = {
                    'type': 'domain_offline',
                    'domain': domain,
                    'error': error_msg, # This was missing a comma
                    'timestamp': datetime.now().isoformat()
                }
                yield f"data: {json.dumps(offline_event)}\n\n"
        
        for round_num in range(1, max_retries + 1):
            # Check if scan was cancelled before starting the round
            if is_scan_cancelled(request_id):
                cancel_event = {
                    'type': 'cancelled',
                    'message': 'Scan cancelled before round started',
                    'timestamp': datetime.now().isoformat()
                }
                yield f"data: {json.dumps(cancel_event)}\n\n"
                # Mark all unscanned domains as failed
                for domain in domains_to_scan:
                    retry_state.add_failure(domain, "Scan cancelled by user", round_num)
                break

            retry_state.current_round = round_num
            
            # Send round start event
            round_start_event = {
                'type': 'round_start',
                'round': round_num,
                'domains_in_round': len(domains_to_scan)
            }
            yield f"data: {json.dumps(round_start_event)}\n\n"
            round_start = datetime.now()  # Track when this round starts
            
            use_cache = (round_num == 1)
            current_timeout = initial_timeout + (timeout_increment * (round_num - 1))
            
            domain_start_times = {}  # Track start times for each domain
            with ThreadPoolExecutor(max_workers=min(2, len(domains_to_scan))) as executor:
                future_to_domain = {
                    executor.submit(handle_scan_with_backoff, domain, use_cache, round_num, current_timeout): domain 
                    for domain in domains_to_scan
                }
                # After creating future_to_domain dictionary, send initial events:
                for domain in domains_to_scan:
                    domain_start_times[domain] = datetime.now()  # Store the start time
                    processing_event = {
                        'type': 'domain_processing',
                        'domain': domain,
                        'status': 'processing',
                        'round': round_num,
                        'started_at': domain_start_times[domain].isoformat()
                    }
                    yield f"data: {json.dumps(processing_event)}\n\n"
                
                for future in as_completed(future_to_domain):
                    # CHECK CANCELLATION FIRST - before processing result
                    if is_scan_cancelled(request_id):
                        executor.shutdown(wait=False, cancel_futures=True)
                        break

                    domain = future_to_domain[future]
                    domain_start = domain_start_times[domain]  # Use the correct start time
                    retry_state.total_processed += 1
                    
                    try:
                        result = future.result()
                        
                        domain_end = datetime.now()
                        duration = (domain_end - domain_start).total_seconds()
                        
                        # Overwrite execution_time_seconds with the numeric duration
                        result["execution_time_seconds"] = round(duration, 2)
                        
                        retry_state.add_success(result) # Now saves a result with numeric duration
                        retry_state.remove_success(domain)
                        
                        # ADD THIS: Save to database
                        if request.save_to_db:
                            db_handler.save_scan_result(result, batch_id)
                        
                        progress_data = {
                            'type': 'domain_complete',
                            'domain': domain,
                            'status': 'completed',
                            'round': round_num,
                            'duration': round(duration, 2),
                            'completed': retry_state.total_processed,
                            'total': len(domains),
                            'percentage': round((retry_state.total_processed / len(domains)) * 100, 2),
                            'result': result,
                            'saved_to_db': request.save_to_db,  # ADD THIS
                            'round_start_time': round_start.isoformat(),
                            'domain_start_time': domain_start.isoformat(),
                            'time_in_current_round': round((datetime.now() - round_start).total_seconds(), 2),
                            'summary': {
                                'successful': len(retry_state.successful_domains),
                                'failed': len(retry_state.failed_domains)
                            }
                        }
                        yield f"data: {json.dumps(progress_data)}\n\n"
                        
                        await asyncio.sleep(5)  # â† Use async sleep here
                        
                    except (HTTPException, Exception) as e:
                        error_msg = e.detail if isinstance(e, HTTPException) else str(e)
                        # Distinguish rate limits from other errors
                        if isinstance(e, HTTPException) and e.status_code == 429:
                            print(f"ðŸš« [{round_num}] Rate Limited: {domain} - will retry with backoff")
                        retry_state.add_failure(domain, error_msg, round_num)
                        
                        domain_end = datetime.now()
                        duration = (domain_end - domain_start).total_seconds()
                        
                        # ADD THIS: Save to database
                        if request.save_to_db:
                            db_handler.save_failed_scan(
                                domain, 
                                error_msg, 
                                batch_id, 
                                f"{request_id}_{domain}")
                        
                        error_data = {
                            'type': 'domain_complete',
                            'domain': domain,
                            'status': 'failed',
                            'round': round_num,
                            'error': error_msg,
                            'completed': retry_state.total_processed,
                            'total': len(domains),
                            'percentage': round((retry_state.total_processed / len(domains)) * 100, 2),
                            'duration': round(duration, 2),
                            'saved_to_db': request.save_to_db,  # ADD THIS
                            'round_start_time': round_start.isoformat(),
                            'domain_start_time': domain_start.isoformat(),
                            'time_in_current_round': round((datetime.now() - round_start).total_seconds(), 2),
                            'summary': {
                                'successful': len(retry_state.successful_domains),
                                'failed': len(retry_state.failed_domains)
                            }
                        }
                        yield f"data: {json.dumps(error_data)}\n\n"
                    
                await asyncio.sleep(0)
            
            # Send round complete event
            round_end = datetime.now()
            round_duration = (round_end - round_start).total_seconds()
            
            round_complete_event = {
                'type': 'round_complete',
                'round': round_num,
                'duration': round(round_duration, 2),
                'domains_processed': len(domains_to_scan)
            }
            yield f"data: {json.dumps(round_complete_event)}\n\n"
            
            # Update domains for next round
            domains_to_scan = retry_state.get_failed_domains()
            
            if not domains_to_scan:
                break
            
            if round_num < max_retries:
                retry_wait_event = {
                    'type': 'retry_wait',
                    'round': round_num,
                    'next_round': round_num + 1,
                    'domains_to_retry': len(domains_to_scan),
                    'delay': retry_delay
                }
                yield f"data: {json.dumps(retry_wait_event)}\n\n"
                
                if clear_cache_between_rounds:
                    clear_ssllabs_cache()
                
                await asyncio.sleep(retry_delay)

        # Send final summary
        end_time = datetime.now()
        # Clean up cancellation state
        clear_cancellation(request_id)

        total_duration = (end_time - start_time).total_seconds()
        round_history_for_summary = []
        
        # Mark remaining unscanned domains as "not_started"
        all_domains_status = {}
        
        # Add successful domains
        for result in retry_state.successful_domains:
            domain = result.get('url', result.get('domain', 'unknown'))
            all_domains_status[domain] = {
                'status': 'completed',
                'duration': result.get('execution_time_seconds'),
                'round': result.get('scan_metadata', {}).get('attempt', 1) if result.get('scan_metadata') else 1,
                'result': result # Include the full result for the domain
            }
        
        # Add failed domains
        for domain, info in retry_state.failed_domains.items():
            all_domains_status[domain] = {
                'status': 'failed',
                'error': info.get('error', 'Unknown error'),
                'round': info.get('last_attempt', 1)
            }

        # Collect round history for the summary
        for i in range(1, retry_state.current_round + 1):
            round_domains = [d for d, s in all_domains_status.items() if s.get('round') == i]
            if round_domains:
                round_history_for_summary.append({
                    'round': i,
                    'domains_processed': len(round_domains),
                    'status': 'completed' # Simplified for summary
                })
        
        final_summary = {
            'type': 'complete',
            'request_id': request_id,
            'batch_id': batch_id,
            'saved_to_db': request.save_to_db,
            'timestamp': end_time.isoformat(),
            'total_duration': round(total_duration, 2),
            'rounds_completed': retry_state.current_round,
            'summary': {
                'total': len(domains),
                'successful': len(retry_state.successful_domains),
                'failed': len(retry_state.failed_domains)
            },
            'successful_domains': [r.get('url', r.get('domain', 'unknown')) for r in retry_state.successful_domains],
            'failed_domains': list(retry_state.failed_domains.keys()),
            'all_domains_status': all_domains_status,  # â† CRITICAL: Include this
            'scanRoundHistory': round_history_for_summary # Add round history to final payload
        }
        
        # ADD THIS: Update final batch status
        if request.save_to_db:
            db_handler.update_batch_status(
                batch_id, 
                "completed",
                len(retry_state.successful_domains),
                len(retry_state.failed_domains)
            )
        
        yield f"data: {json.dumps(final_summary)}\n\n"
    
    return StreamingResponse(
        event_stream(), 
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no"
        }
    )

@app.get("/")
def root():
    """API root endpoint with usage information."""
    return {
        "message": "SSL Labs Scan API with Database Integration",
        "version": "5.0",
        "endpoints": {
            "/scan": "POST - Scan with automatic retry",
            "/scan-with-progress": "POST - Scan with live SSE updates and DB storage",
            "/results": "GET - Fetch scan results from database",
            "/results/batch/{batch_id}": "GET - Get all results for specific batch",
            "/batches": "GET - Get all scan batches",
            "/results/search": "GET - Search scan results with filters",
            "/scans/batch/{batch_id}": "DELETE - Delete a scan batch and its results",
            "/scans/result/{result_id}": "DELETE - Delete a single scan result",
            "/scans/clear-all": "DELETE - Delete ALL data (dangerous)",
            "/cancel-scan/{request_id}": "POST - Cancel ongoing scan",
            "/health": "GET - Health check"
        },
        "features": [
            "âœ… Automatic retry for failed scans (up to 3 rounds)",
            "âœ… In-memory state management (no file storage)",
            "âœ… Cache management between rounds",
            "âœ… Live progress updates via SSE",
            "âœ… PostgreSQL database integration (optional)",
            "âœ… Batch tracking with unique IDs",
            "âœ… Query and search historical results",
            "âœ… Delete individual results or entire batches"
        ],
        "example_request": {
            "domain": "example.com, google.com, github.com",
            "max_concurrent": 5,
            "save_to_db": True
        }
    }

@app.post("/cancel-scan/{request_id}")
def cancel_scan(request_id: str):
    """Cancel an ongoing scan."""
    mark_scan_cancelled(request_id)
    return {
        "status": "cancelled",
        "request_id": request_id,
        "message": "Scan cancellation requested"
    }


@app.get("/health")
def health_check():
    """Health check endpoint."""
    try:
        subprocess.run(
            ["ssllabs-scan", "--help"],
            capture_output=True,
            timeout=5
        )
        return {
            "status": "healthy",
            "ssllabs_cli": "available",
            "version": "4.0"
        }
    except (FileNotFoundError, subprocess.TimeoutExpired):
        return {
            "status": "unhealthy",
            "ssllabs_cli": "not available"
        }

# ============================================================
# DATABASE QUERY ENDPOINTS
# ============================================================

@app.get("/results")
def get_scan_results(
    batch_id: Optional[str] = Query(None, description="Filter by batch ID"),
    limit: int = Query(100, ge=1, le=500),
    offset: int = Query(0, ge=0)
):
    """Fetch scan results from database."""
    return db_handler.get_scan_results(batch_id, limit, offset)

@app.get("/results/batch/{batch_id}")
def get_batch_results(batch_id: str):
    """Get all results for a specific batch."""
    results = db_handler.get_scan_results(batch_id=batch_id, limit=1000)
    batch_info = db_handler.get_batch_info(batch_id)
    
    return {
        "batch_info": batch_info,
        "results": results
    }

@app.get("/batches")
def get_all_batches(
    limit: int = Query(50, ge=1, le=100),
    offset: int = Query(0, ge=0)
):
    """Get all scan batches."""
    return db_handler.get_all_batches(limit, offset)

@app.get("/results/search")
def search_scan_results(
    url: Optional[str] = Query(None, description="Search by URL"),
    status: Optional[str] = Query(None, description="Filter by status"),
    from_date: Optional[str] = Query(None, description="From date (ISO format)"),
    to_date: Optional[str] = Query(None, description="To date (ISO format)"),
    limit: int = Query(100, ge=1, le=500)
):
    """Search scan results with filters."""
    return db_handler.search_scans(url, status, from_date, to_date, limit)

@app.get("/debug/db-connection")
def debug_db_connection():
    """Debug endpoint to test database connectivity."""
    return {
        "db_service_url": db_handler.db_service_url,
        "db_enabled": db_handler.enabled,
        "can_connect": db_handler._check_connection(),
        "timestamp": datetime.now().isoformat()
    }

@app.post("/debug/test-save")
def debug_test_save():
    """Test saving a dummy record to database."""
    test_batch_id = f"test_{int(datetime.now().timestamp())}"
    
    # Try to create a batch
    batch_created = db_handler.create_scan_batch(test_batch_id, 1, 1)
    
    # Try to save a result
    test_result = {
        "request_id": f"test_{int(datetime.now().timestamp())}",
        "url": "test.example.com",
        "requested_at": datetime.now().isoformat(),
        "execution_time_seconds": 1.5,
        "tls_version": "TLS 1.3",
        "cipher_suite_name": "TLS_AES_256_GCM_SHA384",
        "quantum_score": 85,
        "quantum_grade": "A",
        "raw_response": {"test": "data"}
    }
    
    result_saved = db_handler.save_scan_result(test_result, test_batch_id)
    
    # Try to update batch
    batch_updated = db_handler.update_batch_status(test_batch_id, "completed", 1, 0)
    
    return {
        "batch_created": batch_created,
        "result_saved": result_saved,
        "batch_updated": batch_updated,
        "test_batch_id": test_batch_id,
        "db_enabled": db_handler.enabled
    }

# ============================================================
# DELETE ENDPOINTS (Proxy to DB Service)
# ============================================================

@app.delete("/scans/batch/{batch_id}")
def delete_scan_batch_endpoint(batch_id: str = Path(..., description="Batch ID to delete")):
    """
    Delete a scan batch and all its associated results.
    This endpoint proxies to the db-service.
    """
    try:
        success = db_handler.delete_batch_from_db(batch_id)
        
        if success:
            return {
                "message": "Scan batch and all its results deleted successfully",
                "batch_id": batch_id,
                "timestamp": datetime.now().isoformat()
            }
        else:
            raise HTTPException(
                status_code=404, 
                detail=f"Scan batch '{batch_id}' not found or already deleted"
            )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error deleting batch: {str(e)}"
        )


@app.delete("/scans/result/{result_id}")
def delete_scan_result_endpoint(result_id: int = Path(..., description="Result ID to delete")):
    """
    Delete a single scan result.
    This endpoint proxies to the db-service.
    """
    try:
        success = db_handler.delete_result_from_db(result_id)
        
        if success:
            return {
                "message": "Scan result deleted successfully",
                "result_id": result_id,
                "timestamp": datetime.now().isoformat()
            }
        else:
            raise HTTPException(
                status_code=404,
                detail=f"Scan result with ID {result_id} not found or already deleted"
            )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error deleting result: {str(e)}"
        )


@app.delete("/scans/clear-all")
def clear_all_scans_endpoint():
    """
    DANGER: Delete ALL scan batches and results from database.
    This operation cannot be undone.
    This endpoint proxies to the db-service.
    """
    try:
        result = db_handler.clear_all_from_db()
        
        if "error" in result:
            raise HTTPException(
                status_code=500,
                detail=result["error"]
            )
        
        return {
            "message": "All data cleared successfully from database",
            "deleted_results": result.get("deleted_results", 0),
            "deleted_batches": result.get("deleted_batches", 0),
            "timestamp": datetime.now().isoformat()
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error clearing all data: {str(e)}"
        )


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

--- File: C:\Users\ASUS\Videos\xencrypt\scan-service\db_handler.py ---
"""
Database Handler Module
Handles all database operations for SSL scan results
"""
import requests
import logging
import os
from typing import Dict, Any, Optional, List
from datetime import datetime


logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

class DatabaseHandler:
    """Handles all database operations for scan results."""
    
    def __init__(self, db_service_url: Optional[str] = None):
        """Initialize database handler with service URL."""
        self.db_service_url = db_service_url or os.getenv("DB_SERVICE_URL", "http://db-service:8001")
        logger.info("ðŸ“¡ Attempting to connect to database service at: %s", self.db_service_url)
        self.enabled = self._check_connection()
        
        if self.enabled:
            logger.info("âœ… Database service is available and ready!")
        else:
            logger.warning("Database service is NOT available. Data will NOT be persisted!")
    
    def _check_connection(self) -> bool:
        """Check if database service is available."""
        try:
            response = requests.get(f"{self.db_service_url}/health", timeout=5)
            if response.status_code == 200:
                return True
            else:
                logger.warning("âš ï¸ Database health check failed with status: %s, Response: %s", response.status_code, response.text)
                return False
        except requests.exceptions.ConnectionError as e:
            logger.error("âŒ Cannot connect to database service: Connection refused at %s/health", self.db_service_url)
            return False
        except Exception as e:
            logger.error("âŒ Database service connection error: %s", e)
            return False
    
    def create_scan_batch(self, batch_id: str, total_urls: int, max_concurrent: int) -> bool:
        """Create a new scan batch in database."""
        if not self.enabled:
            logger.warning("Database disabled, skipping batch creation for %s", batch_id)
            return False
        
        try:
            payload = {
                "batch_id": batch_id,
                "total_urls": total_urls,
                "max_concurrent": max_concurrent,
                "status": "pending"
            }
            logger.info("ðŸ“¦ Creating batch in database: %s", payload)
            
            response = requests.post(
                f"{self.db_service_url}/scans/batch",
                json=payload,
                timeout=10
            )
            
            if response.status_code == 200:
                logger.info("âœ… Created batch %s in database", batch_id)
                return True
            else:
                logger.error("âŒ Failed to create batch: %s - %s", response.status_code, response.text)
                return False
        except Exception as e:
            logger.exception("Exception creating batch in DB: %s", e)
            return False
    
    def save_scan_result(self, result: Dict[str, Any], batch_id: str) -> bool:
        """Save a successful scan result to database."""
        if not self.enabled:
            logger.warning("Database disabled, skipping result save for %s", result.get('url'))
            return False

        try:
            # Extract raw_response
            raw_response = result.get("raw_response")
            
            # If raw_response is None or empty, construct from available fields
            if not raw_response or not isinstance(raw_response, dict):
                logger.warning("âš ï¸ No valid raw_response for %s, constructing from result fields.", result.get('url'))
                raw_response = {
                    "domain": result.get("url", ""),
                    "quantum_score": result.get("quantum_score"),
                    "quantum_grade": result.get("quantum_grade"),
                    "tls_configuration": {
                        "supported_protocols": []
                    },
                    "pqc_analysis": {
                        "overall_score": result.get("quantum_score"),
                        "overall_grade": result.get("quantum_grade"),
                        "security_level": "unknown",
                        "quantum_ready": False,
                        "hybrid_ready": False
                    } if result.get("quantum_score") else {}
                }

            logger.info("ðŸ’¾ SAVING TO DB: URL: %s, Batch: %s, ReqID: %s, Score: %s, Grade: %s",
                       result.get('url'), batch_id, result.get('request_id'), 
                       result.get('quantum_score'), result.get('quantum_grade'))

            # ðŸ”§ FIX: Map quantum_score/grade to pqc_overall_score/grade
            # The db-service will extract pqc_overall_score/grade from raw_response
            # but we need to include these for backward compatibility and for the validator in schemas.py
            db_data = {
                "batch_id": batch_id,
                "request_id": result.get("request_id"),
                "url": result.get("url"),
                "status": "completed",
                "scan_type": "crypto_audit",
                "requested_at": result.get("requested_at"),
                "completed_at": datetime.now().isoformat(),
                "execution_time_seconds": result.get("execution_time_seconds"),
                "quantum_score": result.get("quantum_score"),
                "quantum_grade": result.get("quantum_grade"),
                "raw_response": raw_response,
                "error_message": None,
            }

            logger.info("-> Sending payload to: %s/scans/result", self.db_service_url)

            response = requests.post(
                f"{self.db_service_url}/scans/result",
                json=db_data,
                timeout=30
            )

            logger.info("<- Response status: %s", response.status_code)
            
            if response.status_code == 200:
                response_data = response.json()
                logger.info("âœ… Successfully saved result to DB! ID: %s, PQC Score: %s",
                           response_data.get('id'), response_data.get('pqc_overall_score'))
                return True
            else:
                logger.error("âŒ Failed to save result: %s - %s", response.status_code, response.text)
                return False

        except Exception as e:
            logger.exception("ðŸ’¥ Exception saving result to DB for URL %s", result.get('url'))
            return False

    def save_failed_scan(self, domain: str, error: str, batch_id: str, request_id: str) -> bool:
        """Save a failed scan to database."""
        if not self.enabled:
            logger.warning("Database disabled, skipping failed scan for %s", domain)
            return False
        
        try:
            db_data = {
                "batch_id": batch_id,
                "request_id": request_id,
                "url": domain,
                "status": "failed",
                "scan_type": "crypto_audit",
                "requested_at": datetime.now().isoformat(),
                "completed_at": datetime.now().isoformat(),
                "error_message": error
            }
            
            logger.info("ðŸ’¾ Saving FAILED scan to database for: %s", domain)
            
            response = requests.post(
                f"{self.db_service_url}/scans/result",
                json=db_data,
                timeout=10
            )
            
            if response.status_code == 200:
                logger.info("âœ… Saved FAILED scan for %s to database", domain)
                return True
            else:
                logger.error("âŒ Failed to save FAILED scan: %s - %s", response.status_code, response.text)
                return False
        except Exception as e:
            logger.exception("Exception saving failed scan to DB: %s", e)
            return False
    
    def update_batch_status(self, batch_id: str, status: str, successful: int = 0, failed: int = 0) -> bool:
        """Update scan batch status in database."""
        if not self.enabled:
            logger.warning("Database disabled, skipping batch update for %s", batch_id)
            return False
        
        try:
            payload = {
                "status": status,
                "successful_count": successful,
                "failed_count": failed
            }
            logger.info("ðŸ”„ Updating batch %s status: %s", batch_id, payload)
            
            response = requests.put(
                f"{self.db_service_url}/scans/batch/{batch_id}",
                json=payload,
                timeout=10
            )
            
            if response.status_code == 200:
                logger.info("âœ… Updated batch %s status to %s", batch_id, status)
                return True
            else:
                logger.error("âŒ Failed to update batch status: %s - %s", response.status_code, response.text)
                return False
        except Exception as e:
            logger.exception("Exception updating batch status: %s", e)
            return False
    
    def get_scan_results(self, batch_id: Optional[str] = None, limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]:
        """Fetch scan results from database."""
        if not self.enabled:
            return []
        
        try:
            params = {"limit": limit, "offset": offset}
            if batch_id:
                params["batch_id"] = batch_id
            
            response = requests.get(
                f"{self.db_service_url}/scans/results",
                params=params,
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                return data if isinstance(data, list) else data.get("results", [])
            else:
                logger.warning("âš ï¸ Failed to fetch results: %s", response.status_code)
                return []
        except Exception as e:
            logger.warning("âš ï¸ Failed to fetch results from DB: %s", e)
            return []
    
    def get_batch_info(self, batch_id: str) -> Optional[Dict[str, Any]]:
        """Get information about a specific batch."""
        if not self.enabled:
            return None
        
        try:
            response = requests.get(
                f"{self.db_service_url}/scans/batch/{batch_id}",
                timeout=10
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                logger.warning("âš ï¸ Failed to fetch batch info for %s: %s", batch_id, response.status_code)
                return None
        except Exception as e:
            logger.warning("âš ï¸ Failed to fetch batch info: %s", e)
            return None
    
    def get_all_batches(self, limit: int = 50, offset: int = 0) -> List[Dict[str, Any]]:
        """Get all scan batches."""
        if not self.enabled:
            return []
        
        try:
            response = requests.get(
                f"{self.db_service_url}/scans/batch",
                params={"limit": limit, "offset": offset},
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                return data if isinstance(data, list) else data.get("batches", [])
            else:
                logger.warning("âš ï¸ Failed to fetch batches: %s", response.status_code)
                return []
        except Exception as e:
            logger.warning("âš ï¸ Failed to fetch batches from DB: %s", e)
            return []
    
    def search_scans(self, url: Optional[str] = None, status: Optional[str] = None, 
                     from_date: Optional[str] = None, to_date: Optional[str] = None,
                     limit: int = 100) -> List[Dict[str, Any]]:
        """Search scan results with filters."""
        if not self.enabled:
            return []
        
        try:
            params = {"limit": limit}
            if url:
                params["url"] = url
            if status:
                params["status"] = status
            if from_date:
                params["from_date"] = from_date
            if to_date:
                params["to_date"] = to_date
            
            response = requests.get(
                f"{self.db_service_url}/scans/results",
                params=params,
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                return data if isinstance(data, list) else data.get("results", [])
            else:
                logger.warning("âš ï¸ Search failed: %s", response.status_code)
                return []
        except Exception as e:
            logger.warning("âš ï¸ Failed to search scans: %s", e)
            return []

    def delete_batch_from_db(self, batch_id: str) -> bool:
        """Delete a batch and all its associated results from database."""
        if not self.enabled:
            logger.warning("Database disabled, skipping batch deletion for %s", batch_id)
            return False
        
        try:
            logger.info("ðŸ—‘ï¸ Deleting batch %s from database...", batch_id)
            
            response = requests.delete(
                f"{self.db_service_url}/scans/batch/{batch_id}",
                timeout=10
            )
            
            if response.status_code == 200:
                logger.info("âœ… Deleted batch %s and all its results from database", batch_id)
                return True
            else:
                logger.error("âŒ Failed to delete batch: %s - %s", response.status_code, response.text)
                return False
        except Exception as e:
            logger.exception("Exception deleting batch from DB: %s", e)
            return False

    def delete_result_from_db(self, result_id: int) -> bool:
        """Delete a single scan result from database."""
        if not self.enabled:
            logger.warning("Database disabled, skipping result deletion for %s", result_id)
            return False
        
        try:
            logger.info("ðŸ—‘ï¸ Deleting result %s from database...", result_id)
            
            response = requests.delete(
                f"{self.db_service_url}/scans/result/{result_id}",
                timeout=10
            )
            
            if response.status_code == 200:
                logger.info("âœ… Deleted result %s from database", result_id)
                return True
            else:
                logger.error("âŒ Failed to delete result: %s - %s", response.status_code, response.text)
                return False
        except Exception as e:
            logger.exception("Exception deleting result from DB: %s", e)
            return False

    def clear_all_from_db(self) -> Dict[str, Any]:
        """Clear all data from database."""
        if not self.enabled:
            logger.warning("Database disabled, skipping clear all operation")
            return {"error": "Database disabled"}
        
        try:
            logger.info("ðŸ—‘ï¸ Clearing ALL data from database...")
            
            response = requests.delete(
                f"{self.db_service_url}/scans/clear-all",
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                logger.info("âœ… Cleared database: %s batches and %s results deleted", 
                       data.get('deleted_batches', 0), data.get('deleted_results', 0))
                return data
            else:
                logger.error("âŒ Failed to clear database: %s", response.status_code)
                return {"error": f"Failed with status {response.status_code}"}
        except Exception as e:
            logger.exception("Exception clearing database: %s", e)
            return {"error": str(e)}

--- File: C:\Users\ASUS\Videos\xencrypt\scan-service\Dockerfile ---
# ============================================================================
# SSL Labs Scanner with Quantum Safety Analysis
# ============================================================================
FROM python:3.11-slim

WORKDIR /app

# ============================================================================
# STAGE 1: Install system dependencies
# ============================================================================
RUN apt-get update && apt-get install -y \
    # Go compiler for ssllabs-scan
    golang \
    git \
    # Network utilities for health checks
    curl \
    # Cleanup to reduce image size
    && rm -rf /var/lib/apt/lists/*

# ============================================================================
# STAGE 2: Install ssllabs-scan CLI (Go binary)
# ============================================================================
RUN go install github.com/ssllabs/ssllabs-scan@latest

# Add Go binaries to PATH
ENV PATH="/root/go/bin:${PATH}"

# Verify ssllabs-scan installation
RUN ssllabs-scan --help

# ============================================================================
# STAGE 3: Install Python dependencies
# ============================================================================
COPY requirements.txt .

RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# ============================================================================
# STAGE 4: Copy application code (FIXED - Copy ALL Python files)
# ============================================================================
COPY crypto_audit.py .
COPY tls.py .
COPY db_handler.py .

# ============================================================================
# STAGE 5: Configuration
# ============================================================================

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=15s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

# Run the application
CMD ["uvicorn", "crypto_audit:app", "--host", "0.0.0.0", "--port", "8000"]

--- File: C:\Users\ASUS\Videos\xencrypt\scan-service\requirements.txt ---
# Core FastAPI server
fastapi==0.109.0
uvicorn[standard]==0.27.0
pydantic==2.5.3
requests
cryptography==42.0.0

--- File: C:\Users\ASUS\Videos\xencrypt\scan-service\tls.py ---
#!/usr/bin/env python3
"""
Post-Quantum Cryptography Security Analyzer
Complete implementation with all algorithms and full CLI
"""

import json
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field, asdict
from enum import Enum
from datetime import datetime
import re


class AlgorithmType(Enum):
    KEX = "key_exchange"
    SIGNATURE = "signature"
    SYMMETRIC = "symmetric"
    HASH = "hash"
    HYBRID = "hybrid"


class SecurityLevel(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    MINIMAL = "minimal"


@dataclass
class AlgorithmScore:
    algorithm: str
    algorithm_type: str
    base_score: float
    key_size: int
    key_size_score: float
    curve_strength: float
    final_score: float
    grade: str
    is_pqc: bool
    is_hybrid: bool
    position: int
    weighted_score: float
    security_level: str
    quantum_safe: bool
    deprecated: bool
    vulnerabilities: List[str] = field(default_factory=list)


@dataclass
class ComponentAnalysis:
    component_type: str
    algorithms: List[AlgorithmScore]
    average_score: float
    weighted_average: float
    grade: str
    weight_in_final: float
    best_algorithm: str
    worst_algorithm: str
    pqc_percentage: float
    hybrid_percentage: float
    deprecated_count: int
    quantum_safe_count: int
    pfs_enabled: bool


@dataclass
class ProtocolAnalysis:
    supported_versions: List[str]
    deprecated_versions: List[str]
    version_scores: Dict[str, float]
    compression_enabled: bool
    renegotiation_secure: bool
    heartbeat_enabled: bool
    session_resumption: str
    downgrade_protection: bool


@dataclass
class CertificateAnalysis:
    total_certificates: int
    weak_signatures: int
    strong_signatures: int
    validity_period_days: int
    cert_transparency: bool
    ocsp_stapling: bool
    key_pinning: bool
    chain_consistent: bool
    signature_algorithms: List[str]
    hash_algorithms: List[str]


@dataclass
class SecurityFeatures:
    hsts_enabled: bool
    hsts_max_age: int
    pfs_supported: bool
    pfs_percentage: float
    sni_supported: bool
    alpn_supported: List[str]
    supported_extensions: List[str]


@dataclass
class FinalReport:
    domain: str
    timestamp: str
    overall_score: float
    overall_grade: str
    security_level: str
    components: Dict[str, ComponentAnalysis]
    individual_scores: List[AlgorithmScore]
    protocol_analysis: ProtocolAnalysis
    certificate_analysis: CertificateAnalysis
    security_features: SecurityFeatures
    quantum_ready: bool
    hybrid_ready: bool
    critical_vulnerabilities: List[str]
    compliance_status: Dict[str, bool]


class PQCAnalyzer:
    """
    Comprehensive Post-Quantum Cryptography Security Analyzer
    """
    
    def __init__(self):
        self.PQ_RESISTANCE_TABLE = {
            "kex": {
                # Classic (Vulnerable to Quantum)
                "RSA": 0, "DH": 0, "DH-RSA": 0, "DH-DSS": 0, "ANON-DH": 0,
                "DHE": 5, "ECDH": 5, "ECDHE": 10,
                
                # Modern Curves
                "X25519": 15, "X448": 18, "CURVE25519": 15, "CURVE448": 18,
                
                # NIST Curves
                "secp224r1": 3, "secp256r1": 5, "secp256k1": 4, "secp384r1": 8,
                "secp521r1": 10, "PRIME256V1": 5,
                
                # Brainpool
                "brainpoolP256r1": 6, "brainpoolP384r1": 9, "brainpoolP512r1": 11,
                
                # FFDHE Groups
                "ffdhe2048": 7, "ffdhe3072": 9, "ffdhe4096": 11,
                "ffdhe6144": 13, "ffdhe8192": 15,
                
                # PQC Standards (NIST)
                "KYBER": 95, "KYBER512": 90, "KYBER768": 95, "KYBER1024": 98,
                "CRYSTALS-KYBER": 95, "ML-KEM": 95, "ML-KEM-512": 90,
                "ML-KEM-768": 95, "ML-KEM-1024": 98,
                
                # PQC Candidates
                "BIKE": 85, "BIKE-L1": 83, "BIKE-L3": 87, "BIKE-L5": 89,
                "SIKE": 0, "NTRU": 85, "NTRUPRIME": 87, "SNTRUP": 86,
                "SNTRUP761": 86, "SNTRUP857": 87, "SNTRUP1277": 89,
                "SABER": 88, "LIGHTSABER": 85, "FIRESABER": 90,
                "FRODO": 92, "FRODOKEM": 92, "FRODOKEM-640": 90,
                "FRODOKEM-976": 92, "FRODOKEM-1344": 94,
                "HQC": 88, "CLASSIC-MCELIECE": 93, "MCELIECE": 93,
                "NEWHOPE": 87, "NEWHOPE512": 85, "NEWHOPE1024": 89,
                "NTRU-HRSS": 87, "NTRU-HPS": 88,
                
                # Hybrid (Best practice)
                "X25519-KYBER768": 96, "X25519-KYBER512": 93,
                "X448-KYBER768": 97, "X448-KYBER1024": 97,
                "P256-KYBER512": 92, "P384-KYBER768": 95,
                "ECDHE-KYBER": 94, "ECDHE-NTRU": 90,
                
                # PSK variants
                "PSK": 40, "DHE-PSK": 45, "ECDHE-PSK": 50,
                "RSA-PSK": 35,
            },
            
            "signature": {
                # Classic (Vulnerable)
                "RSA": 0, "DSA": 0, "DSS": 0, "ECDSA": 5,
                "DSA-1024": 0, "DSA-2048": 3, "DSA-3072": 5,
                
                # RSA Variants
                "RSA-PSS": 8, "RSASSA-PSS": 8,
                
                # Modern ECC
                "EdDSA": 60, "Ed25519": 65, "Ed448": 70,
                
                # PQC Standards (NIST)
                "DILITHIUM": 95, "DILITHIUM2": 92, "DILITHIUM3": 95, "DILITHIUM5": 98,
                "ML-DSA": 95, "ML-DSA-44": 92, "ML-DSA-65": 95, "ML-DSA-87": 98,
                "FALCON": 94, "FALCON512": 92, "FALCON1024": 96,
                "SPHINCS": 96, "SPHINCS+": 97,
                "SPHINCS+-128F": 95, "SPHINCS+-192F": 96, "SPHINCS+-256F": 97,
                "SPHINCS+-128S": 96, "SPHINCS+-192S": 97, "SPHINCS+-256S": 98,
                "SLH-DSA": 97,
                
                # Hash-based
                "XMSS": 91, "LMS": 90, "HSS-LMS": 91,
                
                # PQC Candidates
                "RAINBOW": 0, "PICNIC": 88, "PICNIC3": 89,
                "PICNIC-L1": 87, "PICNIC-L3": 89, "PICNIC-L5": 91, "MAYO": 89, "UOV": 84,
                "GeMSS": 86, "LUOV": 84,
                
                # International Standards
                "SM2": 55, "GOST-SIGNATURE": 58, "GOST-2012": 60,
                
                # Hybrid (Scores reflect the classical part is a vulnerability)
                "RSA-DILITHIUM": 85, "RSA+DILITHIUM": 85,
                "ECDSA-DILITHIUM": 88, "ECDSA+DILITHIUM": 88,
                "ECDSA-FALCON": 87, "ECDSA+FALCON": 87,
                "RSA-SPHINCS+": 86, "RSA-FALCON": 86,
                "Ed25519-DILITHIUM": 90, "Ed448-DILITHIUM3": 91,
                "Ed448-FALCON1024": 92,
            },
            
            "symmetric": {
                # AES Family
                "AES-128": 70, "AES-192": 80, "AES-256": 85,
                "AES-128-GCM": 75, "AES-192-GCM": 82, "AES-256-GCM": 90,
                "AES-128-CCM": 72, "AES-256-CCM": 88,
                "AES-128-OCB": 73, "AES-256-OCB": 89,
                "AES-GCM-SIV": 89, "AES-SIV": 87, "AES-EAX": 86,
                
                # ChaCha Family
                "AEGIS-128": 79, "AEGIS-256": 84,
                "ChaCha20": 82, "ChaCha20-Poly1305": 88,
                "XChaCha20": 83, "XChaCha20-Poly1305": 88,
                
                # Salsa
                "Salsa20": 75, "XSalsa20": 76,
                
                # Other Modern
                "Camellia-128": 60, "Camellia-192": 70, "Camellia-256": 80,
                "ARIA-128": 62, "ARIA-192": 72, "ARIA-256": 82,
                "Twofish": 70, "Twofish-256": 78,
                "Serpent": 75, "Serpent-256": 82,
                
                # Lightweight (NIST)
                "ASCON-128": 80, "ASCON-128A": 82,
                "GIFT-128": 75, "SPARKLE": 76,
                "GRAIN-128AEAD": 74, "TINYJAMBU": 73,
                "DEOXYS-II": 77,
                
                # Weak/Deprecated
                "3DES": 20, "DES": 0, "RC4": 0, "RC2": 0,
                "Blowfish": 30, "IDEA": 25, "CAST5": 28,
            },
            
            "hash": {
                # Broken
                "MD5": 0, "MD4": 0, "MD2": 0,
                
                # Deprecated
                "SHA1": 10, "SHA-1": 10, "RIPEMD-160": 35,
                
                # SHA-2
                "SHA224": 50, "SHA-224": 50, "SHA256": 70, "SHA-256": 70,
                "SHA384": 80, "SHA-384": 80, "SHA512": 85, "SHA-512": 85,
                "SHA512/224": 78, "SHA512/256": 80,
                
                # SHA-3
                "SHA3-224": 70, "SHA3-256": 72, "SHA3-384": 82, "SHA3-512": 88,
                "SHAKE128": 73, "SHAKE256": 86,
                "Keccak": 72, "Keccak-256": 72,
                
                # BLAKE
                "BLAKE2b": 80, "BLAKE2s": 78, "BLAKE3": 85,
                "BLAKE2b-256": 80, "BLAKE2b-512": 83,
                "BLAKE2BP": 82, "BLAKE2SP": 81,
                
                # Lightweight
                "ASCON-HASH": 78, "ASCON-HASHA": 79,
                
                # International
                "Whirlpool": 72, "SM3": 68, "GOST": 60,
                "STREEBOG-256": 65, "STREEBOG-512": 70,
                "LSH-256": 68, "LSH-512": 73, "GOST-HASH": 62,
            }
        }
        
        self.PROTOCOL_SCORES = {
            "SSL 2.0": 0, "SSL 3.0": 0,
            "TLS 1.0": 20, "TLS 1.1": 40, "TLS 1.2": 75, "TLS 1.3": 90,
            "DTLS 1.0": 30, "DTLS 1.2": 75, "DTLS 1.3": 90,
            "QUIC": 85,
        }
        
        self.WEIGHTS = {
            "kex": 0.35, "signature": 0.30, "symmetric": 0.15,
            "certificate": 0.10, "protocol": 0.10,
        }
        
        self.PQC_ALGORITHMS = {
            "KYBER", "BIKE", "SIKE", "NTRU", "SABER", "FRODO", "HQC", "NTRUPRIME",
            "DILITHIUM", "FALCON", "SPHINCS", "RAINBOW", "PICNIC", "GeMSS",
            "XMSS", "LMS", "MCELIECE", "CLASSIC-MCELIECE", "ML-KEM", "ML-DSA",
            "SLH-DSA", "CRYSTALS", "SNTRUP", "LIGHTSABER", "FIRESABER", "FRODOKEM",
            "NEWHOPE", "LUOV",
        }
        
        self.DEPRECATED_ALGORITHMS = {
            "MD5", "MD4", "MD2", "SHA1", "SHA-1", "DES", "3DES", "RC4", "RC2",
            "SSL 2.0", "SSL 3.0", "TLS 1.0", "TLS 1.1", "DSA", "DSS",
            "ANON-DH", "IDEA", "RAINBOW", "SIKE", "DSA-1024",
        }

    def score_to_grade(self, score: float) -> str:
        if score >= 95: return "A+"
        elif score >= 90: return "A"
        elif score >= 85: return "A-"
        elif score >= 80: return "B+"
        elif score >= 75: return "B"
        elif score >= 70: return "B-"
        elif score >= 65: return "C+"
        elif score >= 60: return "C"
        elif score >= 50: return "D"
        else: return "F"

    def get_security_level(self, score: float) -> str:
        if score >= 90: return SecurityLevel.HIGH.value
        elif score >= 70: return SecurityLevel.MEDIUM.value
        elif score >= 50: return SecurityLevel.LOW.value
        else: return SecurityLevel.CRITICAL.value

    def is_hybrid_algorithm(self, algorithm: str) -> bool:
        algo_upper = algorithm.upper()
        hybrid_indicators = ["+", "-", "HYBRID"]
        
        if any(ind in algo_upper for ind in hybrid_indicators):
            has_classical = any(classic in algo_upper for classic in 
                              ["RSA", "ECDSA", "ECDHE", "X25519", "X448", "ED25519", "P256", "P384"])
            has_pqc = any(pqc in algo_upper for pqc in self.PQC_ALGORITHMS)
            return has_classical and has_pqc
        
        return False

    def calculate_key_size_score(self, algorithm: str, key_size: int, algo_type: str) -> float:
        if not key_size:
            return 0.0
        
        algo_upper = algorithm.upper()
        
        if any(x in algo_upper for x in ["RSA", "DSA"]):
            if key_size < 1024: return -40.0
            elif key_size < 2048: return -30.0
            elif key_size == 2048: return 5.0
            elif key_size == 3072: return 10.0
            elif key_size >= 4096: return 15.0
        
        if any(x in algo_upper for x in ["ECDSA", "ECDH", "EC", "ED25519", "ED448"]):
            if key_size < 224: return -25.0
            elif key_size < 256: return -15.0
            elif key_size == 256: return 5.0
            elif key_size == 384: return 10.0
            elif key_size >= 521: return 15.0
        
        if "AES" in algo_upper:
            if key_size == 128: return 0.0
            elif key_size == 192: return 10.0
            elif key_size == 256: return 20.0
        
        if "CHACHA" in algo_upper:
            if key_size == 256: return 15.0
        
        if any(pqc in algo_upper for pqc in self.PQC_ALGORITHMS):
            if key_size >= 3000: return 8.0
            elif key_size >= 1500: return 5.0
            elif key_size >= 800: return 3.0
        
        return 0.0

    def calculate_curve_strength_score(self, curve: str, curve_bits: int) -> float:
        if not curve:
            return 0.0
        
        curve_upper = curve.upper()
        
        if "X25519" in curve_upper or "CURVE25519" in curve_upper:
            return 15.0
        elif "X448" in curve_upper or "CURVE448" in curve_upper:
            return 20.0
        elif "SECP256R1" in curve_upper or "PRIME256V1" in curve_upper:
            return 5.0
        elif "SECP256K1" in curve_upper:
            return 4.0
        elif "SECP384R1" in curve_upper:
            return 10.0
        elif "SECP521R1" in curve_upper:
            return 12.0
        elif "BRAINPOOL" in curve_upper:
            if "512" in curve_upper: return 11.0
            elif "384" in curve_upper: return 9.0
            elif "256" in curve_upper: return 6.0
        
        if curve_bits:
            if curve_bits >= 512: return 12.0
            elif curve_bits >= 384: return 10.0
            elif curve_bits >= 256: return 5.0
            elif curve_bits >= 224: return 3.0
        
        return 0.0

    def parse_algorithm_from_suite(self, suite_name: str, field: str) -> Optional[str]:
        upper_name = suite_name.upper()
        
        if field == "kex":
            # PQC patterns
            for pqc in ["KYBER1024", "KYBER768", "KYBER512", "KYBER", "NTRU", "SABER", "FRODO"]:
                if pqc in upper_name:
                    # Check for hybrid
                    if "X25519" in upper_name:
                        return f"X25519-{pqc}"
                    if "X448" in upper_name:
                        return f"X448-{pqc}"
                    if "P256" in upper_name:
                        return f"P256-{pqc}"
                    if "P384" in upper_name:
                        return f"P384-{pqc}"
                    return pqc
            
            # Standard KEX
            if "ECDHE" in upper_name:
                if "X25519" in upper_name: return "X25519"
                if "X448" in upper_name: return "X448"
                return "ECDHE"
            if "DHE" in upper_name and "ECDHE" not in upper_name:
                return "DHE"
            if "FFDHE8192" in upper_name: return "ffdhe8192"
            if "FFDHE6144" in upper_name: return "ffdhe6144"
            if "FFDHE4096" in upper_name: return "ffdhe4096"
            if "FFDHE3072" in upper_name: return "ffdhe3072"
            if "FFDHE2048" in upper_name: return "ffdhe2048"
            if "DH-RSA" in upper_name: return "DH-RSA"
            if "DH-DSS" in upper_name: return "DH-DSS"
            if "ANON" in upper_name and "DH" in upper_name: return "ANON-DH"
            if "_RSA_" in upper_name or "TLS_RSA_" in upper_name: return "RSA"
            if "ECDH" in upper_name: return "ECDH"
            if "_DH_" in upper_name: return "DH"
            if "PSK" in upper_name:
                if "ECDHE" in upper_name: return "ECDHE-PSK"
                if "DHE" in upper_name: return "DHE-PSK"
                if "RSA" in upper_name: return "RSA-PSK"
                return "PSK"
        
        if field == "symmetric":
            # AEAD modes
            if "AES_256_GCM" in upper_name: return "AES-256-GCM"
            if "AES_192_GCM" in upper_name: return "AES-192-GCM"
            if "AES_128_GCM" in upper_name: return "AES-128-GCM"
            if "AES_256_CCM" in upper_name: return "AES-256-CCM"
            if "AES_128_CCM" in upper_name: return "AES-128-CCM"
            if "AES_256" in upper_name: return "AES-256"
            if "AES_192" in upper_name: return "AES-192"
            if "AES_128" in upper_name: return "AES-128"
            
            # ChaCha
            if "CHACHA20" in upper_name:
                if "POLY1305" in upper_name: return "ChaCha20-Poly1305"
                return "ChaCha20"
            
            # Others
            if "CAMELLIA_256" in upper_name: return "Camellia-256"
            if "CAMELLIA_128" in upper_name: return "Camellia-128"
            if "ARIA_256" in upper_name: return "ARIA-256"
            if "ARIA_128" in upper_name: return "ARIA-128"
            if "ASCON" in upper_name: return "ASCON-128"
            if "3DES" in upper_name: return "3DES"
            if "RC4" in upper_name: return "RC4"
            if "DES" in upper_name and "3DES" not in upper_name: return "DES"
        
        return None

    def parse_signature_algorithm(self, sig_algo: str) -> str:
        upper = sig_algo.upper()
        
        # PQC Signatures
        if "DILITHIUM5" in upper or "ML-DSA-87" in upper: return "DILITHIUM5"
        if "DILITHIUM3" in upper or "ML-DSA-65" in upper: return "DILITHIUM3"
        if "DILITHIUM2" in upper or "ML-DSA-44" in upper: return "DILITHIUM2"
        if "DILITHIUM" in upper or "ML-DSA" in upper: return "DILITHIUM"
        
        if "FALCON1024" in upper: return "FALCON1024"
        if "FALCON512" in upper: return "FALCON512"
        if "FALCON" in upper: return "FALCON"
        
        if "SPHINCS+" in upper or "SLH-DSA" in upper: return "SPHINCS+"
        if "SPHINCS" in upper: return "SPHINCS"
        
        # Hash-based
        if "XMSS" in upper: return "XMSS"
        if "LMS" in upper or "HSS-LMS" in upper: return "LMS"
        
        # Hybrid
        if "RSA" in upper and "DILITHIUM" in upper: return "RSA+DILITHIUM"
        if "ECDSA" in upper and "DILITHIUM" in upper: return "ECDSA+DILITHIUM"
        if "ECDSA" in upper and "FALCON" in upper: return "ECDSA+FALCON"
        if "ED448" in upper and "DILITHIUM" in upper: return "Ed448-DILITHIUM3"
        if "ED448" in upper and "FALCON" in upper: return "Ed448-FALCON1024"
        
        # Modern
        if "ED448" in upper: return "Ed448"
        if "ED25519" in upper or "EDDSA" in upper: return "Ed25519"
        
        # RSA variants
        if "RSA-PSS" in upper or "RSASSA-PSS" in upper: return "RSA-PSS"
        if "ECDSA" in upper: return "ECDSA"
        if "SM2" in upper: return "SM2"
        if "GOST" in upper: return "GOST-SIGNATURE"
        if "RSA" in upper: return "RSA"
        if "DSA" in upper or "DSS" in upper: return "DSA"
        
        return "RSA"

    def parse_hash_algorithm(self, hash_algo: str) -> str:
        upper = hash_algo.upper()
        
        # SHA-3
        if "SHA3-512" in upper or "SHA3_512" in upper: return "SHA3-512"
        if "SHA3-384" in upper or "SHA3_384" in upper: return "SHA3-384"
        if "SHA3-256" in upper or "SHA3_256" in upper: return "SHA3-256"
        if "SHA3" in upper: return "SHA3-256"
        
        # SHAKE
        if "SHAKE256" in upper: return "SHAKE256"
        if "SHAKE128" in upper: return "SHAKE128"
        
        # SHA-2
        if "SHA512/256" in upper: return "SHA512/256"
        if "SHA512" in upper or "SHA-512" in upper: return "SHA512"
        if "SHA384" in upper or "SHA-384" in upper: return "SHA384"
        if "SHA256" in upper or "SHA-256" in upper: return "SHA256"
        if "SHA224" in upper or "SHA-224" in upper: return "SHA224"
        if "SHA1" in upper or "SHA-1" in upper: return "SHA1"
        
        # MD5
        if "MD5" in upper: return "MD5"
        if "MD4" in upper: return "MD4"
        
        # BLAKE
        if "BLAKE3" in upper: return "BLAKE3"
        if "BLAKE2B-512" in upper: return "BLAKE2b-512"
        if "BLAKE2B" in upper: return "BLAKE2b"
        if "BLAKE2S" in upper: return "BLAKE2s"
        
        # Others
        if "ASCON" in upper: return "ASCON-HASH"
        if "STREEBOG-512" in upper: return "STREEBOG-512"
        if "STREEBOG" in upper: return "STREEBOG-256"
        if "LSH-512" in upper: return "LSH-512"
        if "LSH" in upper: return "LSH-256"
        if "WHIRLPOOL" in upper: return "Whirlpool"
        if "SM3" in upper: return "SM3"
        if "RIPEMD" in upper: return "RIPEMD-160"
        if "KECCAK" in upper: return "Keccak"
        if "GOST" in upper: return "GOST-HASH"
        
        return "SHA256"

    def score_individual_algorithm(self, algorithm: str, algo_type: str, 
                                   key_size: Optional[int] = None, curve: Optional[str] = None,
                                   curve_bits: Optional[int] = None, position: int = 0) -> AlgorithmScore:
        
        type_table = self.PQ_RESISTANCE_TABLE.get(algo_type, {})
        base_score = type_table.get(algorithm, None)
        
        if base_score is None:
            algo_upper = algorithm.upper()
            for key in type_table.keys():
                if key.upper() in algo_upper or algo_upper in key.upper():
                    base_score = type_table[key]
                    break
        
        if base_score is None:
            base_score = 0
        
        key_size_score = self.calculate_key_size_score(algorithm, key_size or 0, algo_type)
        curve_strength = self.calculate_curve_strength_score(curve or "", curve_bits or 0)
        
        final_score = base_score + key_size_score + curve_strength
        final_score = max(0, min(100, final_score))
        
        # Gentler positional decay: 1.0, 0.95, 0.91, 0.87 ...
        position_decay = 1.0 / (1 + 0.05 * position) if position >= 0 else 1.0
        weighted_score = final_score * position_decay
        
        is_pqc = any(pqc in algorithm.upper() for pqc in self.PQC_ALGORITHMS)
        is_hybrid = self.is_hybrid_algorithm(algorithm)
        deprecated = any(dep in algorithm.upper() for dep in self.DEPRECATED_ALGORITHMS)
        quantum_safe = is_pqc or (is_hybrid and final_score >= 85)
        grade = self.score_to_grade(final_score)
        security_level = self.get_security_level(final_score)
        
        return AlgorithmScore(
            algorithm=algorithm,
            algorithm_type=algo_type,
            base_score=base_score,
            key_size=key_size or 0,
            key_size_score=key_size_score,
            curve_strength=curve_strength,
            final_score=round(final_score, 2),
            grade=grade,
            is_pqc=is_pqc,
            is_hybrid=is_hybrid,
            position=position,
            weighted_score=round(weighted_score, 2),
            security_level=security_level,
            quantum_safe=quantum_safe,
            deprecated=deprecated,
            vulnerabilities=[]
        )

    def analyze_protocol_features(self, data: Dict) -> ProtocolAnalysis:
        raw = data.get("raw_response", {})
        tls_config = raw.get("tls_configuration", {})
        
        supported_versions = tls_config.get("supported_protocols", [])
        deprecated_versions = [v for v in supported_versions 
                             if v in ["SSL 2.0", "SSL 3.0", "TLS 1.0", "TLS 1.1"]]
        
        version_scores = {}
        for version in supported_versions:
            version_scores[version] = self.PROTOCOL_SCORES.get(version, 50)
        
        compression_enabled = tls_config.get("compression_support", False)
        renegotiation = tls_config.get("renegotiation", {})
        renegotiation_secure = renegotiation.get("secure", True) if renegotiation else True
        heartbeat_enabled = tls_config.get("heartbeat_extension", False)
        session_resumption = tls_config.get("session_resumption", "unknown")
        downgrade_protection = "TLS 1.3" in supported_versions
        
        return ProtocolAnalysis(
            supported_versions=supported_versions,
            deprecated_versions=deprecated_versions,
            version_scores=version_scores,
            compression_enabled=compression_enabled,
            renegotiation_secure=renegotiation_secure,
            heartbeat_enabled=heartbeat_enabled,
            session_resumption=session_resumption,
            downgrade_protection=downgrade_protection
        )

    def analyze_certificate_chain(self, data: Dict, signature_scores: List[AlgorithmScore]) -> CertificateAnalysis:
        raw = data.get("raw_response", {})
        cert_data = raw.get("certificate_chain", {})
        sig_data = raw.get("signature_algorithms", {})
        
        cert_sigs = sig_data.get("certificate_signatures", [])
        weak_sigs = sum(1 for score in signature_scores if score.final_score < 50)
        strong_sigs = sum(1 for score in signature_scores if score.final_score >= 70)
        
        validity_days = cert_data.get("validity_period_days", 0)
        cert_transparency = cert_data.get("certificate_transparency", False)
        ocsp_stapling = cert_data.get("ocsp_stapling", False)
        key_pinning = cert_data.get("public_key_pinning", False)
        
        signature_algos = [cert.get("signature_algorithm", "") for cert in cert_sigs]
        hash_algos = [cert.get("hash_algorithm", "") for cert in cert_sigs]
        chain_consistent = len(set(signature_algos)) <= 2 and len(set(hash_algos)) <= 2
        
        return CertificateAnalysis(
            total_certificates=len(cert_sigs),
            weak_signatures=weak_sigs,
            strong_signatures=strong_sigs,
            validity_period_days=validity_days,
            cert_transparency=cert_transparency,
            ocsp_stapling=ocsp_stapling,
            key_pinning=key_pinning,
            chain_consistent=chain_consistent,
            signature_algorithms=signature_algos,
            hash_algorithms=hash_algos
        )

    def analyze_security_features(self, data: Dict, kex_scores: List[AlgorithmScore]) -> SecurityFeatures:
        raw = data.get("raw_response", {})
        security_data = raw.get("security_features", {})
        tls_config = raw.get("tls_configuration", {})
        
        hsts_enabled = security_data.get("hsts_enabled", False)
        hsts_max_age = security_data.get("hsts_max_age", 0)
        
        pfs_algos = ["DHE", "ECDHE", "X25519", "X448"] + list(self.PQC_ALGORITHMS)
        pfs_count = sum(1 for score in kex_scores 
                       if any(pfs in score.algorithm.upper() for pfs in pfs_algos))
        pfs_supported = pfs_count > 0
        pfs_percentage = (pfs_count / len(kex_scores) * 100) if kex_scores else 0
        
        extensions = tls_config.get("extensions", [])
        sni_supported = "server_name" in extensions or "SNI" in str(extensions).upper()
        alpn_protocols = tls_config.get("alpn_protocols", [])
        
        return SecurityFeatures(
            hsts_enabled=hsts_enabled,
            hsts_max_age=hsts_max_age,
            pfs_supported=pfs_supported,
            pfs_percentage=round(pfs_percentage, 2),
            sni_supported=sni_supported,
            alpn_supported=alpn_protocols,
            supported_extensions=extensions
        )

    def analyze_tls_configuration(self, data: Dict) -> FinalReport:
        raw = data.get("raw_response", {})
        tls_config = raw.get("tls_configuration") or {}
        
        all_scores = []
        component_data = {
            "kex": [], "signature": [], "symmetric": [],
            "certificate": [], "protocol": []
        }
        
        # TLS 1.2 Cipher Suites
        tls12_suites = tls_config.get("tls_1.2_cipher_suites", {}).get("suites", [])
        for position, suite in enumerate(tls12_suites):
            suite_name = suite.get("name", "")
            
            kex_algo = suite.get("key_exchange")
            curve = suite.get("curve")
            curve_bits = suite.get("curve_bits")
            
            if not kex_algo:
                kex_algo = self.parse_algorithm_from_suite(suite_name, "kex")
            
            if kex_algo:
                score = self.score_individual_algorithm(
                    kex_algo, "kex", curve_bits=curve_bits,
                    curve=curve, position=position
                )
                all_scores.append(score)
                component_data["kex"].append(score)
            
            sym_algo = self.parse_algorithm_from_suite(suite_name, "symmetric")
            if sym_algo:
                key_size = 256 if "256" in sym_algo else (192 if "192" in sym_algo else 128)
                score = self.score_individual_algorithm(
                    sym_algo, "symmetric", key_size=key_size, position=position
                )
                all_scores.append(score)
                component_data["symmetric"].append(score)
        
        # TLS 1.3 Cipher Suites
        tls13_suites = tls_config.get("tls_1.3_cipher_suites", {}).get("suites", [])
        for position, suite in enumerate(tls13_suites):
            suite_name = suite.get("name", "")
            kex = suite.get("key_exchange", "")
            curve_bits = suite.get("curve_bits")
            
            if kex:
                score = self.score_individual_algorithm(
                    kex, "kex", curve_bits=curve_bits,
                    curve=kex, position=position
                )
                all_scores.append(score)
                component_data["kex"].append(score)
            
            sym_algo = self.parse_algorithm_from_suite(suite_name, "symmetric")
            if sym_algo:
                key_size = 256 if "256" in sym_algo else (192 if "192" in sym_algo else 128)
                score = self.score_individual_algorithm(
                    sym_algo, "symmetric", key_size=key_size, position=position
                )
                all_scores.append(score)
                component_data["symmetric"].append(score)
        
        # Certificate Signatures
        cert_sigs = raw.get("signature_algorithms", {}).get("certificate_signatures", [])
        for cert in cert_sigs:
            sig_algo = self.parse_signature_algorithm(cert.get("signature_algorithm", ""))
            hash_algo = self.parse_hash_algorithm(cert.get("hash_algorithm", ""))
            key_size = cert.get("public_key_size", 0)
            position = cert.get("position", 0)
            
            sig_score = self.score_individual_algorithm(
                sig_algo, "signature", key_size=key_size, position=position
            )
            all_scores.append(sig_score)
            component_data["signature"].append(sig_score)
            
            hash_score = self.score_individual_algorithm(
                hash_algo, "hash", position=position
            )
            all_scores.append(hash_score)
            component_data["certificate"].append(hash_score)
        
        # Handshake Signatures
        hs_sigs = raw.get("signature_algorithms", {}).get("handshake_signatures", [])
        for idx, hs in enumerate(hs_sigs):
            algo_name = hs.get("algorithm", "")
            sig_algo = self.parse_signature_algorithm(algo_name)
            score = self.score_individual_algorithm(
                sig_algo, "signature", position=idx
            )
            all_scores.append(score)
            component_data["signature"].append(score)
        
        # Protocol Analysis
        protocol_analysis = self.analyze_protocol_features(data)
        for version, score in protocol_analysis.version_scores.items():
            proto_score = self.score_individual_algorithm(version, "protocol", position=0)
            component_data["protocol"].append(proto_score)
        
        # Build Component Analyses
        components = {}
        critical_vulnerabilities = []
        
        for comp_type, scores in component_data.items():
            if not scores or len(scores) == 0:
                continue
            
            final_scores = [s.final_score for s in scores]
            weighted_scores = [s.weighted_score for s in scores]
            
            # The weighted_score already includes position decay.
            # To get the weighted average, we need to normalize by the sum of weights.
            position_weights = [1.0 / (1 + 0.05 * s.position) for s in scores]

            avg_score = sum(final_scores) / len(final_scores)
            weighted_avg = sum(weighted_scores) / sum(position_weights)
            weighted_avg = min(100, weighted_avg)
            
            best_algo = max(scores, key=lambda x: x.final_score).algorithm
            worst_algo = min(scores, key=lambda x: x.final_score).algorithm
            
            pqc_count = sum(1 for s in scores if s.is_pqc)
            pqc_percentage = (pqc_count / len(scores)) * 100
            
            hybrid_count = sum(1 for s in scores if s.is_hybrid)
            hybrid_percentage = (hybrid_count / len(scores)) * 100
            
            deprecated_count = sum(1 for s in scores if s.deprecated)
            quantum_safe_count = sum(1 for s in scores if s.quantum_safe)
            
            pfs_enabled = False
            if comp_type == "kex":
                pfs_algos = ["DHE", "ECDHE", "X25519", "X448"]
                pfs_enabled = any(any(pfs in s.algorithm.upper() for pfs in pfs_algos) 
                                for s in scores)
            
            grade = self.score_to_grade(weighted_avg)
            
            components[comp_type] = ComponentAnalysis(
                component_type=comp_type,
                algorithms=scores,
                average_score=round(avg_score, 2),
                weighted_average=round(weighted_avg, 2),
                grade=grade,
                weight_in_final=self.WEIGHTS.get(comp_type, 0),
                best_algorithm=best_algo,
                worst_algorithm=worst_algo,
                pqc_percentage=round(pqc_percentage, 2),
                hybrid_percentage=round(hybrid_percentage, 2),
                deprecated_count=deprecated_count,
                quantum_safe_count=quantum_safe_count,
                pfs_enabled=pfs_enabled
            )
        
        # Calculate Overall Score
        overall_score = sum(
            comp.weighted_average * comp.weight_in_final 
            for comp in components.values()
        )
        
        overall_grade = self.score_to_grade(overall_score)
        security_level = self.get_security_level(overall_score)
        
        # Additional Features
        cert_analysis = self.analyze_certificate_chain(data, component_data["signature"])
        security_features = self.analyze_security_features(data, component_data["kex"])
        
        # Quantum Readiness
        kex_comp = components.get("kex", None)
        sig_comp = components.get("signature", None)
        
        quantum_ready = (
            overall_score >= 80 and
            ((kex_comp and kex_comp.pqc_percentage > 0) or
             (sig_comp and sig_comp.pqc_percentage > 0) or
             (kex_comp and kex_comp.weighted_average >= 85 and
              sig_comp and sig_comp.weighted_average >= 85)) and
            len(critical_vulnerabilities) == 0
        )
        
        hybrid_ready = any(comp.hybrid_percentage > 0 for comp in components.values())
        
        # Generate Recommendations
        # Check Compliance
        compliance_status = self.check_compliance(
            components, protocol_analysis, cert_analysis, security_features
        )
        
        return FinalReport(
            domain=data.get("url", "Unknown"),
            timestamp=data.get("requested_at", datetime.now().isoformat()),
            overall_score=round(overall_score, 2),
            overall_grade=overall_grade,
            security_level=security_level,
            components=components,
            individual_scores=all_scores,
            protocol_analysis=protocol_analysis,
            certificate_analysis=cert_analysis,
            security_features=security_features,
            quantum_ready=bool(quantum_ready),
            hybrid_ready=hybrid_ready,
            critical_vulnerabilities=critical_vulnerabilities,
            compliance_status=compliance_status
        )

    def check_compliance(self, components: Dict[str, ComponentAnalysis],
                        protocol: ProtocolAnalysis, cert: CertificateAnalysis,
                        security: SecurityFeatures) -> Dict[str, bool]:
        compliance = {
            "PCI DSS 4.0": True, "NIST 800-52r2": True, "FIPS 140-3": True,
            "HIPAA": True, "SOC 2": True, "ISO 27001": True, "CNSA 2.0": False,
        }
        
        if any(v in protocol.supported_versions for v in ["SSL 2.0", "SSL 3.0", "TLS 1.0", "TLS 1.1"]):
            compliance["PCI DSS 4.0"] = False
            compliance["HIPAA"] = False
        
        sym_comp = components.get("symmetric")
        if sym_comp and sym_comp.weighted_average < 60:
            compliance["PCI DSS 4.0"] = False
        
        if "TLS 1.2" not in protocol.supported_versions and "TLS 1.3" not in protocol.supported_versions:
            compliance["NIST 800-52r2"] = False
        
        if cert.weak_signatures > 0:
            compliance["NIST 800-52r2"] = False
        
        fips_approved = ["AES", "SHA256", "SHA384", "SHA512", "RSA", "ECDSA"]
        if sym_comp:
            has_fips = any(any(alg in score.algorithm.upper() for alg in fips_approved) 
                          for score in sym_comp.algorithms)
            if not has_fips:
                compliance["FIPS 140-3"] = False
        
        kex_comp = components.get("kex")
        sig_comp = components.get("signature")
        if kex_comp and kex_comp.pqc_percentage > 0:
            if sig_comp and sig_comp.pqc_percentage > 0:
                compliance["CNSA 2.0"] = True
        
        if any(comp.weighted_average < 50 for comp in components.values()):
            compliance["SOC 2"] = False
            compliance["ISO 27001"] = False
        
        return compliance

    def export_report_json(self, report: FinalReport) -> str:
        def convert_to_dict(obj):
            if hasattr(obj, '__dict__'):
                result = {}
                for key, value in obj.__dict__.items():
                    if isinstance(value, list):
                        result[key] = [convert_to_dict(item) for item in value]
                    elif isinstance(value, dict):
                        result[key] = {k: convert_to_dict(v) for k, v in value.items()}
                    elif hasattr(value, '__dict__'):
                        result[key] = convert_to_dict(value)
                    else:
                        result[key] = value
                return result
            return obj
        
        report_dict = convert_to_dict(report)
        return json.dumps(report_dict, indent=2)

--- File: C:\Users\ASUS\Videos\xencrypt\docker-compose.yml ---
version: '3.8'

services:
  # Frontend Service
  frontend:
    image: node:20
    working_dir: /app
    volumes:
      - ./Frontend:/app
      - /app/node_modules
    ports:
      - "3000:8080"
    command: sh -c "npm install && npm run dev"
    restart: unless-stopped
    networks:
      - xencrypt-network
    depends_on:
      - crypto-scanner
      - db-service

  # Crypto Scanner Service
  crypto-scanner:
    build:
      context: ./scan-service
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    volumes:
      - ./scan-service:/app
    environment:
      - PYTHONUNBUFFERED=1
      - DB_SERVICE_URL=http://db-service:8001
    networks:
      - xencrypt-network
    depends_on:
      db-service:
        condition: service_started
      postgres:
        condition: service_healthy
    restart: unless-stopped

  # Database Service
  db-service:
    build:
      context: ./db-service
      dockerfile: Dockerfile
    ports:
      - "8001:8001"
    volumes:
      - ./db-service:/app
    environment:
      - PYTHONUNBUFFERED=1
      - DATABASE_URL=postgresql://scanuser:scanpass@postgres:5432/scandb
    networks:
      - xencrypt-network
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s

  # PostgreSQL Database
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: scanuser
      POSTGRES_PASSWORD: scanpass
      POSTGRES_DB: scandb
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./postgres-init:/docker-entrypoint-initdb.d
    networks:
      - xencrypt-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U scanuser -d scandb"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    restart: unless-stopped

  # Adminer Web UI (for viewing the database)
  adminer:
    image: adminer
    restart: always
    ports:
      - "8080:8080"
    networks:
      - xencrypt-network

networks:
  xencrypt-network:
    driver: bridge
    name: xencrypt-network

volumes:
  postgres-data:
    driver: local

